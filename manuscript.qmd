---
title: "Binocular integration of chromatic and luminance signals"
author:
  - Daniel H. Baker
  - Kirralise J. Hansford
  - Federico G. Segala
  - Annie Y. Morsi
  - Rowan J. Huxley
  - Joel T. Martin
  - Maya Rockman
  - Alex R. Wade
format:
  pdf:
    keep-tex: true
pdf-engine: xelatex
execute:
  echo: false
bibliography: references.bib
csl: journal-of-vision.csl
header-includes: 
  \usepackage{float} \floatplacement{figure}{H} 
  \newcommand{\beginsupplement}{\setcounter{table}{0}  \renewcommand{\thetable}{A\arabic{table}} \setcounter{figure}{0} \renewcommand{\thefigure}{A\arabic{figure}}}
---

```{r setup, include=FALSE}

processdata <- 1
# the processdata flag has three settings:
# 0: do no analysis, just produce the pdf of the manuscript
# 1: fit psychometric functions and plot graphs
# 2: do Stan modelling and simplex fitting (takes several hours, simplex sometimes gets stuck!)

nsamples <- 100000    # number of Stan samples for modelling
ntotalsimplexfits <- 100    # number of random starting vectors for simplex fits
ncores <- 8    # number of processor cores to use on the host machine
postsampleres <- 200    # resolution of psignifit posterior sampling

# other Stan settings
burnInSteps <- 5000   # Number of steps to "tune" the samplers
thinSteps <- 10
nChains <- 64

# reasonably compact code to check which packages are installed, install the missing ones, and activate all
packagelist <- c('knitr','reticulate','osfr','bookdown','rstan','coda','modeest','pals','pracma','parallel','doParallel','R.matlab','bayestestR','alphahull','kableExtra') # list of CRAN packages
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

# ncores <- parallel::detectCores()  # auto-detect number of cores (optional)

if (processdata>0){
  # use_python('/usr/bin/python3')
  # install_miniconda()
  # use_miniconda('r-reticulate')
  py_install('https://github.com/wichmann-lab/python-psignifit/zipball/master')
  # install psignifit in the terminal with:
  # sudo pip install https://github.com/wichmann-lab/python-psignifit/zipball/master
  ps <- import('psignifit')
  # calculate constant to scale the slope parameter to the Gaussian SD
  C <- ps$utils$my_norminv(1-0.05,0,1) - ps$utils$my_norminv(0.05,0,1)
}

knitr::opts_chunk$set(echo = TRUE)

```

```{r subfunctions, include=FALSE}

# helper functions used throughout the manuscript

addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

lms2rgb <- function(phosphors,fundamentals,lms){
  rgbTOlms <- t(as.matrix(fundamentals)) %*% as.matrix(phosphors)
  lmsTOrgb <- solve(rgbTOlms)
  rgb <- lmsTOrgb %*% lms
return(rgb)}

getmodelresp <- function(p,L,R){
  Lresp <- (L^p[3])/(p[4] + L + p[6]*R)
  Rresp <- (R^p[3])/(p[4] + R + p[6]*L)
  bs <- Lresp + Rresp
  resp <- (bs^p[1])/(p[5] + bs^p[2])
return(resp)}

discriminate <- function(p,pedC,cond) {

  if (cond==1){baseline <- getmodelresp(p,pedC,0)}
  if (cond==2){baseline <- getmodelresp(p,pedC,pedC)}
  if (cond==3){baseline <- getmodelresp(p,pedC,pedC)}
  if (cond==4){baseline <- getmodelresp(p,pedC,0)}

  modelresp <- -10
  contrastinc <- 0
  if (baseline>-999){
    while (((modelresp-baseline) < p[7])){
      contrastinc <- contrastinc + 0.1
  if (cond==1){modelresp <- getmodelresp(p,pedC+contrastinc,0)}
  if (cond==2){modelresp <- getmodelresp(p,pedC+contrastinc,pedC+contrastinc)}
  if (cond==3){modelresp <- getmodelresp(p,pedC+contrastinc,pedC)}
  if (cond==4){modelresp <- getmodelresp(p,pedC,contrastinc)}
    }
    while (((modelresp-baseline) > p[7])){
      contrastinc <- contrastinc - 0.001
  if (cond==1){modelresp <- getmodelresp(p,pedC+contrastinc,0)}
  if (cond==2){modelresp <- getmodelresp(p,pedC+contrastinc,pedC+contrastinc)}
  if (cond==3){modelresp <- getmodelresp(p,pedC+contrastinc,pedC)}
  if (cond==4){modelresp <- getmodelresp(p,pedC,contrastinc)}
    }    
    }
  else{contrastinc <- 99}
return(contrastinc) }

errorfit <- function(p){
  
p <- 10^p
p[2] <- p[2] + 1
p[2] <- min(p[2],16)
p[1] <- 1 + p[1] + p[2]
p[1] <- min(p[1],20)
p[3] <- 1 + p[3]

pedlevelsC <- 10^(pedlist/20)
pedlevelsC[1] <- 0
allpred <- array(0,dim=c(4,length(pedlist)))

  for (cond in 1:4){
    for (pedlev in 1:length(pedlist)){
      allpred[cond,pedlev] <- discriminate(p,pedlevelsC[pedlev],cond)
    }
  }

allpreddB <- 20*log10(allpred)
rms <- sqrt(mean((allpreddB - datatofit)^2))
if (is.na(rms)){rms <- 999}
return(rms)}

extract_polygons <- function(alpha_obj){
  if(class(alpha_obj) != "ashape") stop("extract_polygons requires an ashape")
  edge.df <- as.data.frame(alpha_obj$edges)
  groups <- ns <- xs <- ys <- numeric(nrow(edge.df))
  m <- cbind(edge.df[[1]], edge.df[[2]])
  group <- 1
  repeat {
    i <- which(groups == 0)[1]
    if (length(i) == 0 | is.na(i)) break()
    j <- n <- 1
    repeat {
      groups[i] <- group
      ns[i] <- n
      if(j == 1) xs[i] <- edge.df$x1[i] else xs[i] <- edge.df$x2[i]
      if(j == 1) ys[i] <- edge.df$y1[i] else ys[i] <- edge.df$y2[i]
      next_ind <- which((m[, j] == m[i, j] | m[, (j %% 2 + 1)] == m[i, j]) & groups == 0)
      if (length(next_ind) == 0) break()
      j <- which(m[next_ind,] == m[i, j]) %% 2 + 1
      i <- next_ind
      n <- n + 1
    }
    group <- group + 1
  }
  data.frame(x = xs, y = ys, group = as.factor(groups))[order(groups, ns), ]
}

mkgrating <- function(regionsize, f, o, p, c){
# ported from the Matlab function, originally by Tim Meese
# generates a single component sine wave grating using the following inputs:
  # regionsize is the width of the stimulus
  # f is spatial frequency in cycles per image
  # o is orientation in degrees
  # p is phase in degrees relative to the centre of the image
  # c is contrast

p <- p*(pi/180)   # convert phase from degrees to radians
o <- o*(pi/180)   # convert orientation from degrees to radians
f <- f/regionsize # scale frequency by image size
x0 <- (regionsize+1)/2  # locate centre of image
y0 <- x0

u <- f * cos(o) * 2*pi
v <- f * sin(o) * 2*pi

gridout <- meshgrid(1:regionsize,1:regionsize)   # generate x and y coordinate systems, requires the pracma package
xx <- gridout$X
yy <- gridout$Y

output <- matrix(0,nrow=regionsize,ncol=regionsize)
output <- (c * sin(u * (xx-x0) + v*(yy-y0) + p))

return(output)}

make_soft_window <- function(W,H,D=0.9){
  # Mark's function to make sine-wave gratings, ported from Matlab
  # W is width (in pixels), H is height (in pixels)
  # D is the diameter of the soft window at half height as a proportion of the width
  
  radius <- min(W*D/2,H*D/2)     # radius in pixels
  L <- 2*(min(W/2,H/2) - radius) # blur half-cycle
  X1 <- seq(-L/2,L/2)
  
  X <- (1:W) - (W/2)
  Y <- (1:H) - (H/2)
  xx <- matrix(rep(X,H),nrow=H,ncol=W,byrow=TRUE)
  yy <- t(matrix(rep(Y,W),nrow=W,ncol=H,byrow=TRUE))
  
  mask <- (xx^2 + yy^2)
  mask[mask<=(radius^2)] <- 1
  mask[mask>(radius^2)] <- 0
  
  WinKernel <- cos(X1*pi/L)  # half-cycle cosine
  convkernW <- (1:W)*0
  convkernW[(1+(W/2)-length(X1)/2):((W/2)+length(X1)/2)] <- WinKernel
  convkernH <- (1:H)*0
  convkernH[(1+(H/2)-length(X1)/2):((H/2)+length(X1)/2)] <- WinKernel
  cH <- t(apply(mask,2,convolve,convkernH))
  cH <- cH[,c((1+H/2):H,1:(H/2))]
  cW <- apply(mask,1,convolve,convkernW)
  cW <- cW[c((1+W/2):W,1:(W/2)),]
  mask <- cH * cW
  
  mask <- mask/max(mask)
  
  return(mask)}

```

```{r checkfordata, include=FALSE}

# check for presence of essential data files and folders locally - download from OSF if missing

if (!dir.exists('local')){dir.create('local')}
if (!dir.exists('local/fits')){dir.create('local/fits')}

osfrepo <- '3vdga'
osfproject <- osf_retrieve_node(osfrepo)
osffiles <- osf_ls_files(osfproject,n_max=300)
    
if (!file.exists('local/Experiment1.csv')){osf_download(osffiles[which(osffiles$name=='Experiment1.csv'),],'local/',progress=TRUE)}
if (!file.exists('local/Experiment2.csv')){osf_download(osffiles[which(osffiles$name=='Experiment2.csv'),],'local/',progress=TRUE)}
if (!file.exists('local/Experiment3.csv')){osf_download(osffiles[which(osffiles$name=='Experiment3.csv'),],'local/',progress=TRUE)}
if (!file.exists('local/fundamentals.csv')){osf_download(osffiles[which(osffiles$name=='fundamentals.csv'),],'local/',progress=TRUE)}
if (!file.exists('local/isosettings.csv')){osf_download(osffiles[which(osffiles$name=='isosettings.csv'),],'local/',progress=TRUE)}
if (!file.exists('local/phosphors.csv')){osf_download(osffiles[which(osffiles$name=='phosphors.csv'),],'local/',progress=TRUE)}

if (processdata < 1){
 if (!file.exists('local/thresholddata.RData')){osf_download(osffiles[which(osffiles$name=='thresholddata.RData'),],'local/',progress=TRUE)}
 if (!file.exists('local/thresholddataDisc.RData')){osf_download(osffiles[which(osffiles$name=='thresholddataDisc.RData'),],'local/',progress=TRUE)}
 if (!file.exists('local/MCSdata.RData')){osf_download(osffiles[which(osffiles$name=='MCSdata.RData'),],'local/',progress=TRUE)}
}

if (processdata < 2){
 if (!file.exists('local/simplexfits.RData')){osf_download(osffiles[which(osffiles$name=='simplexfits.RData'),],'local/',progress=TRUE)}
 if (!file.exists('local/stanfit1.RData')){osf_download(osffiles[which(osffiles$name=='stanfit1.RData'),],'local/',progress=TRUE)}
 if (!file.exists('local/stanfit2.RData')){osf_download(osffiles[which(osffiles$name=='stanfit2.RData'),],'local/',progress=TRUE)}
 if (!file.exists('local/stanfit3.RData')){osf_download(osffiles[which(osffiles$name=='stanfit3.RData'),],'local/',progress=TRUE)}
 if (!file.exists('local/stanfit4.RData')){osf_download(osffiles[which(osffiles$name=='stanfit4.RData'),],'local/',progress=TRUE)}
if (!file.exists('local/MCSfit.RData')){osf_download(osffiles[which(osffiles$name=='MCSfit.RData'),],'local/',progress=TRUE)}
}

# if (!file.exists('references.bib')){}
# if (!file.exists('journal-of-vision.csl')){}

```

```{r plotisoluminance, include=FALSE}

if (processdata>0){
  
fundamentals <- read.csv('local/fundamentals.csv')
phosphors <- read.csv('local/phosphors.csv')
thetalist <- (0:360)*pi/180

pdf('Figures/isosettings.pdf',width=11,height=6)

isodata <- read.csv('local/isosettings.csv')
isomeans <- colMeans(isodata)

collist <- brewer.set1(9)

par(mfrow=c(1,2))

ticklocs <- seq(-1,1,0.5)
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-1,1), ylim=c(-1,1))  
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs, line=0.3)    
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="L", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="M", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main='(a) L-M gratings', col.lab=rgb(0,0,0), line=1.5, cex.lab=2)   

lines(c(0,0),c(-1,1),lty=2)
lines(c(-1,1),c(0,0),lty=2)

rgbvals <- matrix(0,nrow=length(thetalist),ncol=3)
for (n in 1:length(thetalist)){
    theta <- thetalist[n]
    stimLMS <- c(cos(theta), sin(theta), 0)
    rgbvals[n,] <- lms2rgb(phosphors,fundamentals,stimLMS)
}

rgbvals <- (rgbvals/(2*max(abs(rgbvals)))) + 0.5
for (n in 1:length(thetalist)){    points(cos(thetalist[n]),sin(thetalist[n]),pch=16,col=rgb(rgbvals[n,1],rgbvals[n,2],rgbvals[n,3]),cex=2)}


arctheta <- seq(60,179,0.5)*pi/180
lines(cos(arctheta)*0.45,sin(arctheta)*0.5,lwd=2);
lines(-cos(arctheta)*0.45,-sin(arctheta)*0.5,lwd=2);

for (s in 1:5){
    a <- isomeans[s]*pi/180
    lines(cos(a)*c(-0.9, 0.9),sin(a)*c(-0.9,0.9),lwd=2,col=collist[s]);
}

legend(-1,-0.25,c('P1','P2','P3','P4','P5'),lwd=2,col=collist[1:5],box.lwd=2,cex=1.2,bg='white')


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-1,1), ylim=c(-1,1))  
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs, line=0.3)    
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="L+M", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="S", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main='(b) S-(L+M) gratings', col.lab=rgb(0,0,0), line=1.5, cex.lab=2)   

lines(c(0,0),c(-1,1),lty=2)
lines(c(-1,1),c(0,0),lty=2)

rgbvals <- matrix(0,nrow=length(thetalist),ncol=3)
for (n in 1:length(thetalist)){
    theta <- thetalist[n]
    stimLMS <- c(cos(theta), cos(theta), sin(theta))
    rgbvals[n,] <- lms2rgb(phosphors,fundamentals,stimLMS)
}

rgbvals <- (rgbvals/(2*max(abs(rgbvals)))) + 0.5
for (n in 1:length(thetalist)){    points(cos(thetalist[n]),sin(thetalist[n]),pch=16,col=rgb(rgbvals[n,1],rgbvals[n,2],rgbvals[n,3]),cex=2)}

arctheta <- seq(45,135,0.5)*pi/180
lines(cos(arctheta)*0.45,sin(arctheta)*0.5,lwd=2);
lines(-cos(arctheta)*0.45,-sin(arctheta)*0.5,lwd=2);

for (s in 1:5){
    a <- isomeans[s+5]*pi/180
    lines(cos(a)*c(-0.9, 0.9),sin(a)*c(-0.9,0.9),lwd=2,col=collist[s]);
}

dev.off()

}

```

```{r loaddata, include=FALSE}

ex1data <- read.csv('local/Experiment1.csv')
ex2data <- read.csv('local/Experiment2.csv')
ex3data <- read.csv('local/Experiment3.csv')

if (processdata>0){
  
sublist <- unique(ex1data$Subject)
explist <- unique(ex1data$Experiment)

options <- NULL
options$sigmoidName <- 'norm'   # choose a cumulative Gauss as the sigmoid
options$expType <- '2AFC'   # choose 2-AFC as the paradigm of the experiment

allthresh <- array(0,dim=c(3,3,4,8))
allslope <- array(0,dim=c(3,3,4,8))
for (subj in 1:3){
  subdata <- subset(ex1data,Subject==sublist[subj])
for (expt in 1:3){
  expdata <- subset(subdata,Experiment==explist[expt])
for (cond in 1:4){
  conddata <- subset(expdata,Condition==(2*cond)|Condition==((2*cond)-1))
  pedlevs <- unique(conddata$PedestalContrast)
for (pedlevel in 1:8){

blockdata <- subset(conddata,PedestalContrast==pedlevs[pedlevel])

if (nrow(blockdata)>0){
targetcontrasts <- sort(unique(blockdata$TargetContrast))
ntrials <- rep(0,length(targetcontrasts))
ncorrect <- rep(0,length(targetcontrasts))
for (lev in 1:length(targetcontrasts)){
  temp <- subset(blockdata,TargetContrast==targetcontrasts[lev])
  ntrials[lev] <- nrow(temp)
  ncorrect[lev] <- sum(temp$IsCorrect)
}

tofit <- as.matrix(data.frame(20*log10(targetcontrasts),ncorrect,ntrials))

res <- ps$psignifit(tofit,options)

allthresh[subj,expt,cond,pedlevel] <- res$Fit[1]
allslope[subj,expt,cond,pedlevel] <- 20*log10(10.3/(res$Fit[2]/C))
}

}}}}

# shift hbin and dich conditions up one
allthresh[,,3,2:8] <- allthresh[,,3,1:7]
allthresh[,,4,2:8] <- allthresh[,,4,1:7]
allslope[,,3,2:8] <- allslope[,,3,1:7]
allslope[,,4,2:8] <- allslope[,,4,1:7]
# duplicate the mon threshold conditions for hbin and dich
allthresh[,,3,1] <- allthresh[,,1,1]
allthresh[,,4,1] <- allthresh[,,1,1]
allslope[,,3,1] <- allslope[,,1,1]
allslope[,,4,1] <- allslope[,,1,1]

meanthresh <- apply(allthresh,2:4,mean)
meanslope <- apply(allslope,2:4,mean)

SEthresh <- apply(allthresh,2:4,sd)/sqrt(3)
SEslope <- apply(allslope,2:4,sd)/sqrt(3)

save(file='local/thresholddata.RData',list=c('allthresh','allslope','meanthresh','meanslope','SEthresh','SEslope'))



pedlist <- c('DET','AC','RG','BY')
tarlist <- c('AC','RG','BY')
sublist <- unique(ex2data$Subject)

ntrials <- array(0,dim=c(length(sublist),12,10))
ncorrect <- ntrials
contrastsC <- ntrials
counter <- 0
for (ped in 1:length(pedlist)){
  for (tar in 1:length(tarlist)){
    counter <- counter + 1
    for (subj in 1:length(sublist)){
    thiscond <- subset(ex2data,Subject==sublist[subj] & TargetType==tarlist[tar] & PedestalType==pedlist[ped])
    targetcontrasts <- sort(as.numeric(unique(thiscond$TargetContrast)))
    for (tlevel in 1:length(targetcontrasts)){
      thislevel <- subset(thiscond, TargetContrast==targetcontrasts[tlevel])
      ntrials[subj,counter,tlevel] <- nrow(thislevel)
      ncorrect[subj,counter,tlevel] <- sum(thislevel$IsCorrect)
      contrastsC[subj,counter,tlevel] <- targetcontrasts[tlevel]
    }
  }
}
}

MCSpropcorr <- 100*ncorrect/ntrials
contrastsdB <- round(20*log10(contrastsC))

MCSthresh <- matrix(0,nrow=length(sublist),ncol=12)
MCSslope <- MCSthresh
for (subj in 1:length(sublist)){
for (cond in 1:12){
  datatofit <- data.frame(contrastsdB[subj,cond,],ncorrect[subj,cond,],ntrials[subj,cond,])
  colnames(datatofit) <- c('CdB','Ncorrect','Ntrials')

  res <- ps$psignifit(as.matrix(datatofit),options)
  
  MCSthresh[subj,cond] <- res$Fit[1]
  MCSslope[subj,cond] <- 20*log10(10.3/(res$Fit[2]/C))

}}

thdelev <- array(0,dim=c(3,3,3))
slopematrix <- array(0,dim=c(3,3,3))

for (subj in 1:length(sublist)){
thdelev[subj,1,] <- MCSthresh[subj,c(4,7,10)] - MCSthresh[subj,1]
thdelev[subj,2,] <- MCSthresh[subj,c(5,8,11)] - MCSthresh[subj,2]
thdelev[subj,3,] <- MCSthresh[subj,c(6,9,12)] - MCSthresh[subj,3]

slopematrix[subj,1,] <- MCSslope[subj,c(4,7,10)]
slopematrix[subj,2,] <- MCSslope[subj,c(5,8,11)]
slopematrix[subj,3,] <- MCSslope[subj,c(6,9,12)]
}
detslopes <- MCSslope[,1:3]

options$stepN <- as.integer(c(postsampleres,postsampleres,20,20,20))
allposteriors <- array(0,dim=c(12,postsampleres,postsampleres))
allposX <- array(0,dim=c(12,postsampleres))
allposY <- array(0,dim=c(12,postsampleres))

# now also pool across subjects and fit for plotting the full posterior
for (cond in 1:12){
  datatofit <- data.frame(contrastsdB[1,cond,],colSums(ncorrect[,cond,]),colSums(ntrials[,cond,]))
  colnames(datatofit) <- c('CdB','Ncorrect','Ntrials')
  res <- ps$psignifit(as.matrix(datatofit),options)

  xycos <- res$X1D
  a <- res$Posterior
  sumpos <- apply(a,c(1,2),sum)

  allposteriors[cond,,] <- sumpos
  allposX[cond,] <- xycos[[1]]
  allposY[cond,] <- xycos[[2]]
  
}

save(file='local/MCSdata.RData',list=c('MCSthresh','MCSslope','thdelev','slopematrix','detslopes','MCSpropcorr','contrastsdB','allposteriors','allposX','allposY'))



sublist3 <- unique(ex3data$Subject)

allthresh3 <- array(0,dim=c(length(sublist3),4,8))
allslope3 <- array(0,dim=c(length(sublist3),4,8))
for (subj in 1:length(sublist3)){
  subdata <- subset(ex3data,Subject==sublist3[subj])
for (cond in 1:4){
  conddata <- subset(subdata,Condition==(2*cond)|Condition==((2*cond)-1))
  pedlevs <- unique(conddata$PedestalContrast)
for (pedlevel in 1:8){

blockdata <- subset(conddata,PedestalContrast==pedlevs[pedlevel])

if (nrow(blockdata)>0){
targetcontrasts <- sort(unique(blockdata$TargetContrast))
ntrials <- rep(0,length(targetcontrasts))
ncorrect <- rep(0,length(targetcontrasts))
for (lev in 1:length(targetcontrasts)){
  temp <- subset(blockdata,TargetContrast==targetcontrasts[lev])
  ntrials[lev] <- nrow(temp)
  ncorrect[lev] <- sum(temp$IsCorrect)
}

tofit <- as.matrix(data.frame(20*log10(targetcontrasts),ncorrect,ntrials))

res <- ps$psignifit(tofit,options)

allthresh3[subj,cond,pedlevel] <- res$Fit[1]
allslope3[subj,cond,pedlevel] <- 20*log10(10.3/(res$Fit[2]/C))
}

}}}

# shift hbin and dich conditions up one
allthresh3[,3,2:8] <- allthresh3[,3,1:7]
allthresh3[,4,2:8] <- allthresh3[,4,1:7]
allslope3[,3,2:8] <- allslope3[,3,1:7]
allslope3[,4,2:8] <- allslope3[,4,1:7]
# duplicate the mon threshold conditions for hbin and dich
allthresh3[,3,1] <- allthresh3[,1,1]
allthresh3[,4,1] <- allthresh3[,1,1]
allslope3[,3,1] <- allslope3[,1,1]
allslope3[,4,1] <- allslope3[,1,1]

meanthresh3 <- apply(allthresh3,2:3,mean)
meanslope3 <- apply(allslope3,2:3,mean)

SEthresh3 <- apply(allthresh3,2:3,sd)/sqrt(length(sublist3))
SEslope3 <- apply(allslope3,2:3,sd)/sqrt(length(sublist3))

save(file='local/thresholddataDisc.RData',list=c('allthresh3','allslope3','meanthresh3','meanslope3','SEthresh3','SEslope3'))


}

```

```{r domodellingsimplex, include=FALSE}

load('local/thresholddata.RData')
load('local/thresholddataDisc.RData')

if (processdata==2){

cluster <- makeCluster(ncores)
registerDoParallel(cluster)

pedlist <<- seq(-12,30,6)
allp <- matrix(0,nrow=4,ncol=7)
allparams <- array(0,dim=c(4,ntotalsimplexfits,8))
allrms <- NULL
 for (cond in 1:3){
   print(cond)
   datatofit <<- meanthresh[cond,,]

   nfits <- ntotalsimplexfits
   for (n in 1:ntotalsimplexfits){
     if (file.exists(paste0('local/fits/E',cond,'f',n,'.RData'))){nfits <- nfits-1}
   }
   
   if (nfits > 0){
   foreach(i = 1:nfits, .combine=rbind) %dopar% {
   sout <- pracma::nelder_mead(errorfit,rnorm(7,sd=0.1)+log10(c(0.5,5.5,0.3,1,0.01,1,0.2)))
   allout <- c(errorfit(sout$xmin),sout$xmin)

   hassaved <- 0
   filecount <- 0
   while (!hassaved){
     filecount <- filecount + 1
     if (!file.exists(paste0('local/fits/E',cond,'f',filecount,'.RData'))){
       save(file=paste0('local/fits/E',cond,'f',filecount,'.RData'),list='allout')
       hassaved <- 1}
   }
   allout <- c(errorfit(sout$xmin),sout$xmin)
   }
   }
   
   finalout <- matrix(0,nrow=ntotalsimplexfits,ncol=8)
   for (n in 1:ntotalsimplexfits){
     if (file.exists(paste0('local/fits/E',cond,'f',n,'.RData'))){
       load(file=paste0('local/fits/E',cond,'f',n,'.RData'))
       finalout[n,] <- allout
     }
   }
   i <- which(finalout[,1]==min(finalout[,1]))
   p <- 10^finalout[i[1],2:8]
   allrms[cond] <- finalout[i[1],1]
   p[2] <- p[2] + 1
   p[2] <- min(p[2],16)
   p[1] <- 1 + p[1] + p[2]
   p[1] <- min(p[1],20)
   p[3] <- 1 + p[3]
   allp[cond,] <- p
   allparams[cond,,] <- finalout
   
   pedlist <<- seq(-6,36,6)  # increase pedestal contrasts for the chromatic conditions

 } 


# finally fit the disc data
pedlist <<- seq(-12,30,6)
cond <- 4

   print(cond)
   datatofit <<- meanthresh3

   nfits <- ntotalsimplexfits
   for (n in 1:ntotalsimplexfits){
     if (file.exists(paste0('local/fits/E',cond,'f',n,'.RData'))){nfits <- nfits-1}
   }
   
   if (nfits > 0){
   foreach(i = 1:nfits, .combine=rbind) %dopar% {
   sout <- pracma::nelder_mead(errorfit,rnorm(7,sd=0.1)+log10(c(0.5,5.5,0.3,1,0.01,1,0.2)))
   allout <- c(errorfit(sout$xmin),sout$xmin)

   hassaved <- 0
   filecount <- 0
   while (!hassaved){
     filecount <- filecount + 1
     if (!file.exists(paste0('local/fits/E',cond,'f',filecount,'.RData'))){
       save(file=paste0('local/fits/E',cond,'f',filecount,'.RData'),list='allout')
       hassaved <- 1}
   }
   allout <- c(errorfit(sout$xmin),sout$xmin)
   }
   }
   
   finalout <- matrix(0,nrow=ntotalsimplexfits,ncol=8)
   for (n in 1:ntotalsimplexfits){
     if (file.exists(paste0('local/fits/E',cond,'f',n,'.RData'))){
       load(file=paste0('local/fits/E',cond,'f',n,'.RData'))
       finalout[n,] <- allout
     }
   }
   i <- which(finalout[,1]==min(finalout[,1]))
   p <- 10^finalout[i[1],2:8]
   allrms[cond] <- finalout[i[1],1]
   p[2] <- p[2] + 1
   p[2] <- min(p[2],16)
   p[1] <- 1 + p[1] + p[2]
   p[1] <- min(p[1],20)
   p[3] <- 1 + p[3]
   allp[cond,] <- p
   allparams[cond,,] <- finalout
   
  
save(file='local/simplexfits.RData',list=c('allp','allrms','allparams','ntotalsimplexfits'))

stopCluster(cluster)
  
}

```

```{r plotdippers, include=FALSE}

if (processdata>0){
  
load('local/simplexfits.RData')

pedlist <- -12:39
pedlevelsC <- 10^(pedlist/20)
pedlevelsC[1] <- 0
allpred <- array(0,dim=c(4,4,length(pedlist)))

for (expt in 1:4){
  for (cond in 1:4){
    for (pedlev in 1:length(pedlist)){
      allpred[expt,cond,pedlev] <- discriminate(allp[expt,],pedlevelsC[pedlev],cond)
    }
  }
}
allpreddB <- 20*log10(allpred)

pdf('Figures/dipperssimplex.pdf',width=12,height=10)

collist <- c('red','blue','orange','darkgreen')

ticklocsx <- seq(-12,36,6)
ticklabelsx <- c(0,0.5,1,2,4,8,16,32,64)
ticklocsy <- seq(-12,36,6)
ticklabelsy <- c(0.25,0.5,1,2,4,8,16,32,64)
pedcontrasts <- seq(-12,30,6)

exptorder <- c(1,3,2)
paneltitles <- c('(a) Achromatic thresholds','(b) Red/Green thresholds','(c) Blue/Yellow thresholds')
par(mfrow=c(2,3))
for (expt in 1:3){
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-12,39))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main=paneltitles[expt],cex.main=2.5)


for (cond in 1:4){
  arrows(pedcontrasts,meanthresh[exptorder[expt],cond,],pedcontrasts,meanthresh[exptorder[expt],cond,]+SEthresh[exptorder[expt],cond,],col=collist[cond],angle=90,length=0.02,lwd=2)
 arrows(pedcontrasts,meanthresh[exptorder[expt],cond,],pedcontrasts,meanthresh[exptorder[expt],cond,]-SEthresh[exptorder[expt],cond,],col=collist[cond],angle=90,length=0.02,lwd=2)  
  # lines(pedcontrasts,meanthresh[1,cond,],col=collist[cond],lwd=2)
  lines(pedlist,allpreddB[exptorder[expt],cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,meanthresh[exptorder[expt],cond,],pch=16,col=collist[cond],cex=1.5)
}
text(24,-9,paste0('RMSE = ',round(allrms[expt],digits=2),'dB'),cex=2)
if (expt==1){legend(-12,36,c('Monocular','Binocular','Half-binocular','Dichoptic'),pch=16,col=collist,box.lwd=2,cex=1.5)}

pedcontrasts <- c(-12,seq(0,36,6))  # update pedestal contrasts for plotting chromatic conditions

}

paneltitles <- c('(d) Achromatic slopes','(e) Red/Green slopes','(f) Blue/Yellow slopes')

ticklocsy <- seq(-6,18,6)
ticklabelsy <- c(0.5,1,2,4,8)

for (expt in 1:3){

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-6,18))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab=expression(paste('Weibull ', beta)), col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main=paneltitles[expt],cex.main=2.5)

for (cond in 1:4){
  arrows(pedcontrasts,meanslope[expt,cond,],pedcontrasts,meanslope[expt,cond,]+SEslope[expt,cond,],col=collist[cond],angle=90,length=0.02,lwd=2)
 arrows(pedcontrasts,meanslope[expt,cond,],pedcontrasts,meanslope[expt,cond,]-SEslope[expt,cond,],col=collist[cond],angle=90,length=0.02,lwd=2)  
  lines(pedcontrasts,meanslope[expt,cond,],col=collist[cond],lwd=2)
  # lines(pedlist,allpreddB[4,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,meanslope[expt,cond,],pch=16,col=collist[cond],cex=1.5)
}

}

dev.off()
  

pdf('Figures/discdata.pdf',width=13,height=7)

par(mfcol=c(1,2))
pedcontrasts <- seq(-12,30,6)

ticklocsy <- seq(-18,30,6)
ticklabelsy <- c(0.125,0.25,0.5,1,2,4,8,16,32)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-18,30))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main='(a) Flickering disc (thresholds)',cex.main=2)


for (cond in 1:4){
  arrows(pedcontrasts,meanthresh3[cond,],pedcontrasts,meanthresh3[cond,]+SEthresh3[cond,],col=collist[cond],angle=90,length=0.02,lwd=2)
 arrows(pedcontrasts,meanthresh3[cond,],pedcontrasts,meanthresh3[cond,]-SEthresh3[cond,],col=collist[cond],angle=90,length=0.02,lwd=2)  
  # lines(pedcontrasts,meanthresh[1,cond,],col=collist[cond],lwd=2)
  lines(pedlist,allpreddB[4,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,meanthresh3[cond,],pch=16,col=collist[cond],cex=1.5)
}
text(24,-15,paste0('RMSE = ',round(allrms[4],digits=2),'dB'),cex=2)
legend(-12,30,c('Monocular','Binocular','Half-binocular','Dichoptic'),pch=16,col=collist,box.lwd=2,cex=1.5)


ticklocsy <- seq(-6,18,6)
ticklabelsy <- c(0.5,1,2,4,8)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-6,18))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab=expression(paste('Weibull ', beta)), col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main='(b) Flickering disc (slopes)',cex.main=2)

for (cond in 1:4){
  arrows(pedcontrasts,meanslope3[cond,],pedcontrasts,meanslope3[cond,]+SEslope3[cond,],col=collist[cond],angle=90,length=0.02,lwd=2)
 arrows(pedcontrasts,meanslope3[cond,],pedcontrasts,meanslope3[cond,]-SEslope3[cond,],col=collist[cond],angle=90,length=0.02,lwd=2)  
  lines(pedcontrasts,meanslope3[cond,],col=collist[cond],lwd=2)
  # lines(pedlist,allpreddB[4,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,meanslope3[cond,],pch=16,col=collist[cond],cex=1.5)
}

dev.off()

}

summation <- meanthresh[,1,1] - meanthresh[,2,1]
summationDisc <- meanthresh3[1,1] - meanthresh3[2,1]


```

```{r stanmodelspecifications, include=FALSE}

modelString = "
  data {
    int<lower=1> Ndatasets ;
    int<lower=1> Ntotal ;
    int ncorrect[Ntotal] ;
    int ntrials[Ntotal] ;
    real PedestalContrast[Ntotal] ;
    real TargetContrast[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;  
  }
  parameters {
    vector<lower=0.1, upper=3>[Ndatasets] p;
    vector<lower=2, upper=8>[Ndatasets] q;
    vector<lower=0.5, upper=2>[Ndatasets] m;
    vector<lower=0.001, upper=2>[Ndatasets] S;  
    vector<lower=0.001, upper=2>[Ndatasets] Z;
    vector<lower=0.001, upper=2>[Ndatasets] w;
    vector<lower=0.001, upper=2>[Ndatasets] k;

    real<lower=0> sigma ;
    real<lower=0.1, upper=3> pmu ; 
    real<lower=2, upper=8> qmu ; 
    real<lower=0.5, upper=2> mmu ;
    real<lower=0.001, upper=2> Smu ;
    real<lower=0.001, upper=2> Zmu ; 
    real<lower=0.001, upper=2> wmu ; 
    real<lower=0.001, upper=2> kmu ;
    
    real<lower=0> psigma ;
    real<lower=0> qsigma ;
    real<lower=0> msigma ;
    real<lower=0> Ssigma ;
    real<lower=0> Zsigma ;    
    real<lower=0> wsigma ;
    real<lower=0> ksigma ;    
  }
  model {
  
    pmu ~ normal( 1.4 , 0.1 ) ;
    qmu ~ normal( 6.59 , 0.5 ) ;
    mmu ~ normal( 1.28 , 0.2 ) ;
    Smu ~ normal( 0.985 , 0.2 ) ;
    Zmu ~ normal( 0.08 , 0.5 ) ;
    wmu ~ normal( 1 , 0.2 ) ;
    kmu ~ normal( 0.194 , 0.1 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    psigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    qsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    msigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Ssigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;    
    wsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    
    p ~ normal( pmu , psigma ) ; // vectorized
    q ~ normal( qmu , qsigma ) ; // vectorized
    m ~ normal( mmu , msigma ) ; // vectorized
    S ~ normal( Smu , Ssigma ) ; // vectorized
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    w ~ normal( wmu , wsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized

    for ( i in 1:Ntotal ) {
      
    real Lt ;
    real Rt ;
    real Ln ;
    real Rn ;
    real targresp ;
    real nullresp ;
    real dprime ;
      
    if (c[i]==1) { // monocular condition
    Lt = pow(PedestalContrast[i]+TargetContrast[i],m[s[i]]) / (S[s[i]] + (PedestalContrast[i]+TargetContrast[i])) ;
    Rt = 0 ;
    Ln = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i]) ;
    Rn = 0 ; 
    }
          
    if (c[i]==2) { // binocular condition 
      Lt = pow(PedestalContrast[i]+TargetContrast[i],m[s[i]]) / (S[s[i]] + (PedestalContrast[i]+TargetContrast[i]) + w[s[i]]*(PedestalContrast[i]+TargetContrast[i])) ;
      Rt = pow(PedestalContrast[i]+TargetContrast[i],m[s[i]]) / (S[s[i]] + (PedestalContrast[i]+TargetContrast[i]) + w[s[i]]*(PedestalContrast[i]+TargetContrast[i])) ;
      Ln = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i] + w[s[i]]*PedestalContrast[i]) ;
      Rn = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i] + w[s[i]]*PedestalContrast[i]) ;
    }
    
    if (c[i]==3) { // half-binocular condition 
      Lt = pow(PedestalContrast[i]+TargetContrast[i],m[s[i]]) / (S[s[i]] + (PedestalContrast[i]+TargetContrast[i]) + w[s[i]]*PedestalContrast[i]) ;
      Rt = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i] + w[s[i]]*(PedestalContrast[i]+TargetContrast[i])) ;
      Ln = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i] + w[s[i]]*PedestalContrast[i]) ;
      Rn = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i] + w[s[i]]*PedestalContrast[i]) ;  
    }
    
    if (c[i]==4) { // dichoptic condition 
      Lt = pow(TargetContrast[i],m[s[i]]) / (S[s[i]] + TargetContrast[i] + w[s[i]]*PedestalContrast[i]) ;
      Rt = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i] + w[s[i]]*TargetContrast[i]) ;
      Ln = 0 ;
      Rn = pow(PedestalContrast[i],m[s[i]]) / (S[s[i]] + PedestalContrast[i]) ;      
    }
    
    targresp = pow((Lt + Rt), (p[s[i]]+q[s[i]])) / (Z[s[i]] + pow((Lt + Rt), q[s[i]])) ;
    nullresp = pow((Ln + Rn), (p[s[i]]+q[s[i]])) / (Z[s[i]] + pow((Ln + Rn), q[s[i]])) ;     

    dprime = (targresp-nullresp)/k[s[i]] ;
    if (is_nan(dprime)){
       dprime = 0;
    }
    if (is_inf(dprime)){
       dprime = 10;
    }
    if (dprime > 10){
       dprime = 10;
    }    
    ncorrect[i] ~ binomial(ntrials[i], Phi(dprime/sqrt(2))) ;
    }
  }  
" # close quote for modelString



crossmodelString = "
  data {
    int<lower=1> Ndatasets ;
    int<lower=1> Ntotal ;
    int ncorrect[Ntotal] ;
    int ntrials[Ntotal] ;
    real PedestalContrast[Ntotal] ;
    real TargetContrast[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;  
  }
  parameters {
    vector<lower=0, upper=40>[Ndatasets] Zac;
    vector<lower=0, upper=40>[Ndatasets] Zrg;
    vector<lower=0, upper=40>[Ndatasets] Zby;
    vector<lower=0.001, upper=2>[Ndatasets] wAcR;
    vector<lower=0.001, upper=2>[Ndatasets] wAcB;
    vector<lower=0.001, upper=2>[Ndatasets] wRgA;
    vector<lower=0.001, upper=2>[Ndatasets] wRgB;
    vector<lower=0.001, upper=2>[Ndatasets] wByA;
    vector<lower=0.001, upper=2>[Ndatasets] wByR;

    real<lower=0> sigma ;
    real<lower=0, upper=40> Zacmu ; 
    real<lower=0, upper=40> Zrgmu ; 
    real<lower=0, upper=40> Zbymu ; 
    real<lower=0.001, upper=2> wAcRmu ; 
    real<lower=0.001, upper=2> wAcBmu ; 
    real<lower=0.001, upper=2> wRgAmu ; 
    real<lower=0.001, upper=2> wRgBmu ; 
    real<lower=0.001, upper=2> wByAmu ; 
    real<lower=0.001, upper=2> wByRmu ; 

    real<lower=0> Zacsigma ;    
    real<lower=0> Zrgsigma ;    
    real<lower=0> Zbysigma ;    
    real<lower=0> wAcRsigma ;
    real<lower=0> wAcBsigma ;
    real<lower=0> wRgAsigma ;
    real<lower=0> wRgBsigma ;
    real<lower=0> wByAsigma ;
    real<lower=0> wByRsigma ;
  }
  model {
    Zacmu ~ normal( 10 , 5 ) ;
    Zrgmu ~ normal( 10 , 5 ) ;
    Zbymu ~ normal( 10 , 5 ) ;
    wAcRmu ~ normal( 0.5 , 0.3 ) ;
    wAcBmu ~ normal( 0.5 , 0.3 ) ;
    wRgAmu ~ normal( 0.5 , 0.3 ) ;
    wRgBmu ~ normal( 0.5 , 0.3 ) ;
    wByAmu ~ normal( 0.5 , 0.3 ) ;
    wByRmu ~ normal( 0.5 , 0.3 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zacsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;    
    Zrgsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;    
    Zbysigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;    
    wAcRsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wAcBsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wRgAsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wRgBsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wByAsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wByRsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    
    Zac ~ normal( Zacmu , Zacsigma ) ; // vectorized
    Zrg ~ normal( Zrgmu , Zrgsigma ) ; // vectorized
    Zby ~ normal( Zbymu , Zbysigma ) ; // vectorized
    wAcR ~ normal( wAcRmu , wAcRsigma ) ; // vectorized
    wAcB ~ normal( wAcBmu , wAcBsigma ) ; // vectorized
    wRgA ~ normal( wRgAmu , wRgAsigma ) ; // vectorized
    wRgB ~ normal( wRgBmu , wRgBsigma ) ; // vectorized
    wByA ~ normal( wByAmu , wByAsigma ) ; // vectorized
    wByR ~ normal( wByRmu , wByRsigma ) ; // vectorized

    for ( i in 1:Ntotal ) {
      
    real Lt ;
    real Rt ;
    real Ln ;
    real Rn ;
    real targresp ;
    real nullresp ;
    real dprime ;
      
    if (c[i]==1) { // achromatic detection condition
    Lt = pow(TargetContrast[i],1.21) / (1.03 + (TargetContrast[i])) ;
    Rt = 0 ;
    Ln = 0 ;
    Rn = 0 ; 
    
    targresp = pow((Lt + Rt), 7.82) / (Zac[s[i]] + pow((Lt + Rt), 6.4)) ;
    nullresp = pow((Ln + Rn), 7.82) / (Zac[s[i]] + pow((Ln + Rn), 6.4)) ;     

    }
          
    if (c[i]==2) { // red/green detection condition
    Lt = pow(TargetContrast[i],1.21) / (1.03 + (TargetContrast[i])) ;
    Rt = 0 ;
    Ln = 0 ;
    Rn = 0 ; 
    
    targresp = pow((Lt + Rt), 7.82) / (Zrg[s[i]] + pow((Lt + Rt), 6.4)) ;
    nullresp = pow((Ln + Rn), 7.82) / (Zrg[s[i]] + pow((Ln + Rn), 6.4)) ;     

    }
    
    if (c[i]==3) { // blue/yellow detection condition
    Lt = pow(TargetContrast[i],1.21) / (1.03 + (TargetContrast[i])) ;
    Rt = 0 ;
    Ln = 0 ;
    Rn = 0 ; 
    
    targresp = pow((Lt + Rt), 7.82) / (Zby[s[i]] + pow((Lt + Rt), 6.4)) ;
    nullresp = pow((Ln + Rn), 7.82) / (Zby[s[i]] + pow((Ln + Rn), 6.4)) ;     

    }
    
    if (c[i]==4) { // achromatic target, achromatic mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + 1*PedestalContrast[i]) ;
      Rt = pow(PedestalContrast[i],1.21) / (1.03 + PedestalContrast[i] + 1*TargetContrast[i]) ;
      Ln = 0 ;
      Rn = pow(PedestalContrast[i],1.21) / (1.03 + PedestalContrast[i]) ;  
      
      targresp = pow((Lt + Rt), 7.82) / (Zac[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zac[s[i]] + pow((Ln + Rn), 6.4)) ;     

    }
    
    if (c[i]==5) { // red/green target, achromatic mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + wRgA[s[i]]*PedestalContrast[i]) ;
      Rt = 0 ;
      Ln = 0 ;
      Rn = 0 ;   
      
      targresp = pow((Lt + Rt), 7.82) / (Zrg[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zrg[s[i]] + pow((Ln + Rn), 6.4)) ;     
    }

    if (c[i]==6) { // blue/yellow target, achromatic mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + wByA[s[i]]*PedestalContrast[i]) ;
      Rt = 0 ;
      Ln = 0 ;
      Rn = 0 ;   
      
      targresp = pow((Lt + Rt), 7.82) / (Zby[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zby[s[i]] + pow((Ln + Rn), 6.4)) ;     
    }    
    
    
    if (c[i]==7) { // achromatic target, red/green mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + wAcR[s[i]]*PedestalContrast[i]) ;
      Rt = 0 ;
      Ln = 0 ;
      Rn = 0 ;  
      
      targresp = pow((Lt + Rt), 7.82) / (Zac[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zac[s[i]] + pow((Ln + Rn), 6.4)) ;     

    }
    
    if (c[i]==8) { // red/green target, red/green mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + 1*PedestalContrast[i]) ;
      Rt = pow(PedestalContrast[i],1.21) / (1.03 + PedestalContrast[i] + 1*TargetContrast[i]) ;
      Ln = 0 ;
      Rn = pow(PedestalContrast[i],1.21) / (1.03 + PedestalContrast[i]) ;  
      
      targresp = pow((Lt + Rt), 7.82) / (Zrg[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zrg[s[i]] + pow((Ln + Rn), 6.4)) ;     
    }

    if (c[i]==9) { // blue/yellow target, red/green mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + wByR[s[i]]*PedestalContrast[i]) ;
      Rt = 0 ;
      Ln = 0 ;
      Rn = 0 ;   
      
      targresp = pow((Lt + Rt), 7.82) / (Zby[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zby[s[i]] + pow((Ln + Rn), 6.4)) ;     
    }      
    
    
     if (c[i]==10) { // achromatic target, blue/yellow mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + wAcB[s[i]]*PedestalContrast[i]) ;
      Rt = 0 ;
      Ln = 0 ;
      Rn = 0 ;  
      
      targresp = pow((Lt + Rt), 7.82) / (Zac[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zac[s[i]] + pow((Ln + Rn), 6.4)) ;     

    }
    
    if (c[i]==11) { // red/green target, blue/yellow mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + wRgB[s[i]]*PedestalContrast[i]) ;
      Rt = 0 ;
      Ln = 0 ;
      Rn = 0 ;  
      
      targresp = pow((Lt + Rt), 7.82) / (Zrg[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zrg[s[i]] + pow((Ln + Rn), 6.4)) ;     
    }

    if (c[i]==12) { // blue/yellow target, blue/yellow mask
      Lt = pow(TargetContrast[i],1.21) / (1.03 + TargetContrast[i] + 1*PedestalContrast[i]) ;
     Rt = pow(PedestalContrast[i],1.21) / (1.03 + PedestalContrast[i] + 1*TargetContrast[i]) ;
      Ln = 0 ;
      Rn = pow(PedestalContrast[i],1.21) / (1.03 + PedestalContrast[i]) ;  
  
      targresp = pow((Lt + Rt), 7.82) / (Zby[s[i]] + pow((Lt + Rt), 6.4)) ;
      nullresp = pow((Ln + Rn), 7.82) / (Zby[s[i]] + pow((Ln + Rn), 6.4)) ;     
    }      
    
    dprime = (targresp-nullresp)/0.23 ;
    if (is_nan(dprime)){
       dprime = 0;
    }
    if (is_inf(dprime)){
       dprime = 10;
    }
    if (dprime > 10){
       dprime = 10;
    }    
    ncorrect[i] ~ binomial(ntrials[i], Phi(dprime/sqrt(2))) ;
    }
  }  
" # close quote for modelString


```

```{r domodellingstan, include=FALSE}

if (processdata==2){
  
numSavedSteps <- nsamples    # total number of MCMC steps
options(mc.cores=ncores)

# Translate to C++ and compile to DSO:
dipmodel <- stan_model(model_code=modelString)  

ex1data <- read.csv('local/Experiment1.csv')
ex1data$Condition <- ceiling(ex1data$Condition/2)
ex3data <- read.csv('local/Experiment3.csv')
ex3data$Condition <- ceiling(ex3data$Condition/2)

sublist <- unique(ex1data$Subject)
explist <- unique(ex1data$Experiment)
counter <- 0
datasetcounter <- 0
ntrials <- NULL
ncorrect <- NULL
subjects <- NULL
experiments <- NULL
datasets <- NULL
conditions <- NULL
pedestals <- NULL
targets <- NULL

for (s in 1:3){
  for (e in 1:3){
    datasetcounter <- datasetcounter + 1
    for (cond in 1:4){
      thisdipper <- subset(ex1data,Subject==sublist[s] & Experiment==explist[e] & Condition==cond)
      
      pedconts <- sort(unique(thisdipper$PedestalContrast))

      for (p in 1:length(pedconts)){
        thisthresh <- subset(thisdipper,PedestalContrast==pedconts[p])
        targconts <- sort(unique(thisthresh$TargetContrast))
        for (t in 1:length(targconts)){
          counter <- counter + 1
          thislevel <- subset(thisthresh,TargetContrast==targconts[t])
          ntrials[counter] <- nrow(thislevel)
          ncorrect[counter] <- sum(thislevel$IsCorrect)
          subjects[counter] <- s
          experiments[counter] <- e
          datasets[counter] <- datasetcounter
          conditions[counter] <- cond
          pedestals[counter] <- pedconts[p]
          targets[counter] <- targconts[t]
        }
      }
    }
  }
}

sublist3 <- unique(ex3data$Subject)
for (s in 1:length(sublist3)){
    datasetcounter <- datasetcounter + 1
    for (cond in 1:4){
      thisdipper <- subset(ex3data,Subject==sublist3[s] & Condition==cond)
      
      pedconts <- sort(unique(thisdipper$PedestalContrast))

      for (p in 1:length(pedconts)){
        thisthresh <- subset(thisdipper,PedestalContrast==pedconts[p])
        targconts <- sort(unique(thisthresh$TargetContrast))
        for (t in 1:length(targconts)){
          counter <- counter + 1
          thislevel <- subset(thisthresh,TargetContrast==targconts[t])
          ntrials[counter] <- nrow(thislevel)
          ncorrect[counter] <- sum(thislevel$IsCorrect)
          subjects[counter] <- s
          experiments[counter] <- 4
          datasets[counter] <- datasetcounter
          conditions[counter] <- cond
          pedestals[counter] <- pedconts[p]
          targets[counter] <- targconts[t]
        }
      }
    }
}

expdata <- data.frame(datasets,experiments,subjects,conditions,pedestals,targets,ntrials,ncorrect)

for (expt in 1:4){

thisexpt <- subset(expdata, experiments==expt)

dataList = list(ncorrect = thisexpt$ncorrect, ntrials = thisexpt$ntrials, PedestalContrast = thisexpt$pedestals, TargetContrast = thisexpt$targets, c = thisexpt$conditions, s = thisexpt$subjects, Ndatasets = length(unique(thisexpt$subjects)), Ntotal = nrow(thisexpt))

# Get MC sample of posterior:
stanFit <- sampling(object=dipmodel, 
                    data = dataList, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0('local/stanfit',expt,'.RData'),list=c('stanFit'))

}

}

```

```{r plotstanmodels, include=FALSE}

allstanparams <- matrix(0,nrow=4,ncol=7)
upperstanparams <- matrix(0,nrow=4,ncol=7)
lowerstanparams <- matrix(0,nrow=4,ncol=7)

load(paste0('local/stanfit1.RData'))
draws <- extract(stanFit)
p <- draws$pmu
allsamples <- array(0,dim=c(4,7,length(p)))

for (expt in 1:4){
  load(paste0('local/stanfit',expt,'.RData'))
  draws <- extract(stanFit)
  p <- mean(draws$pmu+draws$qmu)
  q <- mean(draws$qmu)
  m <- mean(draws$mmu)
  k <- mean(draws$kmu)
  S <- mean(draws$Smu)
  Z <- mean(draws$Zmu)
  w <- mean(draws$wmu)
  allstanparams[expt,] <- c(p,q,m,S,Z,w,k)
  
  plist <- draws$pmu+draws$qmu
  qlist <- draws$qmu
  mlist <- draws$mmu
  klist <- draws$kmu
  Slist <- draws$Smu
  Zlist <- draws$Zmu
  wlist <- draws$wmu
  
  allsamples[expt,1,] <- plist
  allsamples[expt,2,] <- qlist
  allsamples[expt,3,] <- mlist
  allsamples[expt,4,] <- Slist
  allsamples[expt,5,] <- Zlist
  allsamples[expt,6,] <- wlist
  allsamples[expt,7,] <- klist
  
  # quants <- quantile(wlist,probs=c(0.025,0.975))
  # i <- which.min(abs(wlist-quants[1]))
  # lowerstanparams[expt,] <- allsamples[expt,,i]
  # i <- which.min(abs(wlist-quants[2]))
  # upperstanparams[expt,] <- allsamples[expt,,i]
}

if (processdata>0){

load('local/thresholddata.RData')
load('local/thresholddataDisc.RData')

threshtoplot <- array(0,dim=c(4,4,8))
threshtoplot[1:3,,] <- meanthresh
threshtoplot[4,,] <- meanthresh3


  pdf(paste0('Figures/stanoutput.pdf'),width=8,height=8)
  
  layout(matrix(c(1,1,2,2,3,3,4,4,1,1,2,2,3,3,4,4,8,8,8,9,9,9,5,5,8,8,8,9,9,9,5,5,8,8,8,9,9,9,6,6,10,10,10,11,11,11,6,6,10,10,10,11,11,11,7,7,10,10,10,11,11,11,7,7),8,8,byrow=TRUE))
  par(mar=c(3,2,1,1))
  
  concols1 <- c('black','darkred','darkblue','white')
  concols2 <- c('black','darkgreen','gold','black')
  
  paramorder <- c('p','q','m',expression(omega),'S','Z','k')
  paramvalorder <- c(1,2,3,6,4,5,7)
  
  xstart <- c(1,1,1/2,1/2,1/4,1/64,1/16)
  xstartdB <- round(20*log10(xstart))
  xstep <- c(6,6,3,3,6,12,6)
  
  for (param in 1:7){
    
    ticklocsx <- seq(xstartdB[param],xstartdB[param]+xstep[param]*(4),xstep[param])
    
    ticklabelsx <- c('1/4','1/2',1,2,4)
    if (param<3){ticklabelsx <- c(1,2,4,8,16)}
    if (param==3 || param==4){ticklabelsx <- c('1/2','','1','','2')}
    if (param>5){ticklabelsx <- c('1/16','1/8','1/4','1/2','1')}
    if (param==6){ticklabelsx <- c('1/64','1/16','1/4','1','4')}
    
    plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(xstartdB[param],xstartdB[param]+xstep[param]*4), ylim=c(0,1))
    axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
    
    mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)
    title(xlab=paramorder[param], col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
    
    for (expt in 1:4){
    svals <- 20*log10(allsamples[expt,paramvalorder[param],])
    a <- density(svals)
    a$y <- a$y/max(a$y)
    # lines(a$x,a$y,col=collist[expt])
    polygon(a$x,a$y,border=NA,col=addalpha(concols1[expt],alpha=0.25))
    lines(a$x,a$y,col=concols2[expt],lwd=2)
    }
    
    if (param==1){
      legend(0,1,c('Achromatic','Red/green','Blue/yellow','Flicker'),fill=addalpha(concols1,alpha=0.25),border=concols2,box.lwd=2)
    }
    
  }
  
paneltitles <- c('(a) Achromatic grating','(b) Red/green grating','(c) Blue/yellow grating','(d) Flickering disc')
    
  for (expt in 1:4){
    print(expt)
  pedlist <- -12:36
  pedlevelsC <- 10^(pedlist/20)
  pedlevelsC[1] <- 0
  allpred <- array(0,dim=c(4,length(pedlist)))
  # upperpred <- array(0,dim=c(4,length(pedlist)))
  # lowerpred <- array(0,dim=c(4,length(pedlist)))
  for (cond in 1:4){
    for (pedlev in 1:length(pedlist)){
      allpred[cond,pedlev] <- discriminate(allstanparams[expt,],pedlevelsC[pedlev],cond)
      # upperpred[cond,pedlev] <- discriminate(upperstanparams[expt,],pedlevelsC[pedlev],cond)
      # lowerpred[cond,pedlev] <- discriminate(lowerstanparams[expt,],pedlevelsC[pedlev],cond)
    }
  }

  collist <- c('red','blue','orange','darkgreen')
  
  allpreddB <- 20*log10(allpred)
  # lowerpreddB <- 20*log10(lowerpred)
  # upperpreddB <- 20*log10(upperpred)
  
  par(mar=c(3,4,2,1))
  
  ticklocsx <- seq(-12,36,6)
  ticklabelsx <- c(0,0.5,1,2,4,8,16,32,64)
  ticklocsy <- seq(-12,36,6)
  ticklabelsy <- c(0.25,0.5,1,2,4,8,16,32,64)
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-12,39))
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main=paneltitles[expt],cex.main=2)
  pedcontrasts <- seq(-12,30,6)
  
  for (cond in 1:4){

    # polygon(pedlist[c(1:length(pedlist),length(pedlist):1)],c(lowerpreddB[cond,],upperpreddB[cond,length(pedlist):1]),border=NA,col=addalpha(collist[cond],alpha=0.2))
    lines(pedlist,allpreddB[cond,],col=collist[cond],lwd=2)
    # points(pedcontrasts,threshtoplot[expt,cond,],pch=16,col=collist[cond],cex=1.5)
  }
  # text(-9,33,paste0('(',letters[expt],')'),cex=2)
  # legend(-12,42,c('Monocular','Binocular','Half-binocular','Dichoptic'),pch=16,col=collist,box.lwd=2,cex=1.5)
  }
  
  dev.off()
  
}

```

```{r plotMCS, include=FALSE}

load('local/MCSdata.RData')
meanslopesMCS <- apply(slopematrix,c(2,3),mean)
meanslopesMCS <- round(10^(meanslopesMCS/20),digits=2)

if (processdata>0){

  propcorr <- apply(MCSpropcorr,2:3,mean)
  contrastsdB <- contrastsdB[1,,]
  
ticklocsx <- seq(-12,42,6)
ticklabelsx <- c('1/4','1/2','1','2','4','8','16','32','64','128')
ticklocsy <- seq(0,100,25)
ticklabelsy <- ticklocsy

titlelist <- c('(a) Achromatic target','(b) R/G target','(c) B/Y target','(d) Achromatic densities','(e) R/G densities','(f) B/Y densities','(g) Threshold elevation','(h) Psychometric slope')

    pdf(paste0('Figures/MCSdata.pdf'),width=12,height=12)
  
    layout(matrix(c(1,1,2,2,3,3,4,4,5,5,6,6,0,7,7,8,8,0),3,6,byrow=TRUE))
  
  for (cond in 1:3){

  par(pty="s")
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,42), ylim=c(0,100))  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)    # titles for axes
  title(ylab="Percent correct", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)
  title(main=titlelist[cond],cex.main=2)
  
  lines(c(-12,42),c(50,50),lty=2)
  
  lines(contrastsdB[cond,],propcorr[cond,],lwd=3)
  points(contrastsdB[cond,],propcorr[cond,],pch=21,lwd=3,cex=2,bg='black')
  
  lines(contrastsdB[cond+3,],propcorr[cond+3,],lwd=3)
  points(contrastsdB[cond+3,],propcorr[cond+3,],pch=21,lwd=3,cex=2,col='black',bg='white')

  lines(contrastsdB[cond+6,],propcorr[cond+6,],lwd=3)
  points(contrastsdB[cond+6,],propcorr[cond+6,],pch=21,lwd=3,cex=2,col='red',bg='green')

  lines(contrastsdB[cond+9,],propcorr[cond+9,],lwd=3)
  points(contrastsdB[cond+9,],propcorr[cond+9,],pch=21,lwd=3,cex=2,col='cornflowerblue',bg='gold')
  
  # text(18,10,paste(ntrials[1],'trials/level'),pos=4)
  
  legend(-2,40,c('Target only','Achromatic mask','R/G mask','B/Y mask'), pch=21, col=c('black','black','red','cornflowerblue'),pt.cex=2,cex=1.5,pt.lwd=3,pt.bg=c('black','white','green','gold'),box.lwd=2)
  
  }
    
outlinecolours <- c('black','black','red','cornflowerblue')
shadingcolours <- c('black','white','green','gold')

ticklocsx <- seq(-12,42,6)
ticklabelsx <- c('1/4','1/2','1','2','4','8','16','32','64','128')
ticklocsy <- seq(0,24,6)
ticklabelsy <- c('1','2','4','8','16')
    
thd <- 0.28

for (cond in 1:3){

    par(pty="s")  
 plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,42), ylim=c(0,24))  

axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)    # titles for axes
title(ylab=expression(paste('Weibull ', beta)), col.lab=rgb(0,0,0), line=2, cex.lab=1.5)
  title(main=titlelist[cond+3],cex.main=2)

for (block in 1:4){
condtoplot <- cond + ((block-1)*3)

xvals <- allposX[condtoplot,]
yvals <- 10.3/(allposY[condtoplot,ncol(allposY):1]/C)
zvals <- allposteriors[condtoplot,,ncol(allposY):1]

binz <- zvals/max(zvals)
iind <- which(binz>thd,arr.ind=TRUE)

xy <- matrix(0,nrow=nrow(iind),ncol=2)
xy[,1] <- xvals[iind[,1]]
xy[,2] <- yvals[iind[,2]]
hullobj <- ashape(xy,alpha=1)
polys <- extract_polygons(hullobj)
polygon(polys$x,20*log10(polys$y),col=shadingcolours[block],border=NA)
lines(polys$x[c(1:nrow(polys),1)],20*log10(polys$y[c(1:nrow(polys),1)]),lwd=2,col=outlinecolours[block])
}
 
for (block in 1:4){
condtoplot <- cond + ((block-1)*3)
points(MCSthresh[,condtoplot],MCSslope[,condtoplot],pch=21,col=outlinecolours[block],bg=shadingcolours[block])
}
}    
    
    
    
  par(pty="s")

plotlims <- c(0.5,3.5,0.5,3.5)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocs <- seq(1,3)    # locations of tick marks on x axis
ticklabels <- c('ACH','R/G','B/Y')
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabels, side = 1, at=ticklocs,line=0.5) 
mtext(text = ticklabels, side = 2, at=ticklocs, line=0.2, las=1) 
title(xlab="Target", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Mask", col.lab=rgb(0,0,0), line=2.5, cex.lab=1.5)
title(main=titlelist[7],cex.main=2)

thdelev <- apply(thdelev,c(2,3),mean)

ramp2 <- colorRamp(c("white","cornflowerblue"))  # create a ramp from one colour to another
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)
image(1:3,1:3,thdelev,zlim=c(0,30),col=colmatrix2,add=TRUE,useRaster=FALSE)

thdfactor <- round(10^(thdelev/20),digits=2)
counter <- 0
for (x in 1:3){
  for (y in 1:3){
    text(x,y,thdfactor[x,y],cex=1.6)
  }
}


par(pty="s")

plotlims <- c(0.5,3.5,0.5,3.5)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocs <- seq(1,3)    # locations of tick marks on x axis
ticklabels <- c('ACH','R/G','B/Y')
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabels, side = 1, at=ticklocs,line=0.5) 
mtext(text = ticklabels, side = 2, at=ticklocs, line=0.2, las=1) 
title(xlab="Target", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Mask", col.lab=rgb(0,0,0), line=2.5, cex.lab=1.5)
title(main=titlelist[8],cex.main=2)

ramp2 <- colorRamp(c("white","darkgreen"))  # create a ramp from one colour to another
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)
image(1:3,1:3,meanslopesMCS,zlim=c(0,8),col=colmatrix2,add=TRUE,useRaster=FALSE)

counter <- 0
for (x in 1:3){
  for (y in 1:3){
    text(x,y,meanslopesMCS[x,y],cex=1.6)
  }
}

  dev.off()

  
}

```

```{r domodellingMCS, include=FALSE}

if (processdata==2){
  
numSavedSteps <- nsamples    # total number of MCMC steps
options(mc.cores=ncores)

# Translate to C++ and compile to DSO:
mcsmodel <- stan_model(model_code=crossmodelString)  

ex2data <- read.csv('local/Experiment2.csv')

sublist <- unique(ex2data$Subject)
targetlist <- unique(ex2data$TargetType)
pedlist <- unique(ex2data$PedestalType)
pedlist <- pedlist[c(4,1,3,2)]  # reorder to make life easier later

counter <- 0
datasetcounter <- 0
ntrials <- NULL
ncorrect <- NULL
subjects <- NULL
datasets <- NULL
conditions <- NULL
pedestals <- NULL
targets <- NULL

for (s in 1:3){
    datasetcounter <- datasetcounter + 1
    conditioncounter <- 0
    for (pedtype in 1:4){
    for (targtype in 1:3){
      conditioncounter <- conditioncounter + 1
      thiscond <- subset(ex2data,Subject==sublist[s] & TargetType==targetlist[targtype] & PedestalType==pedlist[pedtype])
      
        pedcont <- sort(unique(thiscond$PedestalContrast))
        targconts <- sort(unique(thiscond$TargetContrast))
        
        for (t in 1:length(targconts)){
          counter <- counter + 1
          thislevel <- subset(thiscond,TargetContrast==targconts[t])
          ntrials[counter] <- nrow(thislevel)
          ncorrect[counter] <- sum(thislevel$IsCorrect)
          subjects[counter] <- s
          datasets[counter] <- datasetcounter
          conditions[counter] <- conditioncounter
          pedestals[counter] <- pedcont
          targets[counter] <- targconts[t]

      }
    }
  }
}

thisexpt <- data.frame(datasets,subjects,conditions,pedestals,targets,ntrials,ncorrect)

dataList = list(ncorrect = thisexpt$ncorrect, ntrials = thisexpt$ntrials, PedestalContrast = thisexpt$pedestals, TargetContrast = thisexpt$targets, c = thisexpt$conditions, s = thisexpt$subjects, Ndatasets = length(unique(thisexpt$subjects)), Ntotal = nrow(thisexpt))

# Get MC sample of posterior:
stanFit <- sampling(object=mcsmodel, 
                    data = dataList, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0('local/MCSfit.RData'),list=c('stanFit'))

}

```

```{r plotMCSstan, include=FALSE}

getmodelresp3inputs <- function(p,La,Ra,Lr,Rr,Lb,Rb){
  
  maxlength <- max(length(La),length(Ra),length(Lr),length(Rr),length(Lb),length(Rb))
  resp <- matrix(0,nrow=3,ncol=maxlength)
  
  LrespA <- (La^1.21)/(1.03 + La + Ra + p[4]*Rr + p[5]*Rb)
  RrespA <- (Ra^1.21)/(1.03 + Ra + La + p[4]*Lr + p[5]*Lb)
  LrespR <- (Lr^1.21)/(1.03 + Lr + p[6]*Ra + Rr + p[7]*Rb)
  RrespR <- (Rr^1.21)/(1.03 + Rr + p[6]*La + Lr + p[7]*Lb)
  LrespB <- (Lb^1.21)/(1.03 + Lb + p[8]*Ra + p[9]*Rr + Rb)
  RrespB <- (Rb^1.21)/(1.03 + Rb + p[8]*La + p[9]*Lr + Lb)
  
  bs <- LrespA + RrespA
  resp[1,] <- (bs^7.82)/(p[1] + bs^6.4)
  
  bs <- LrespR + RrespR
  resp[2,] <- (bs^7.82)/(p[2] + bs^6.4)
  
  bs <- LrespB + RrespB
  resp[3,] <- (bs^7.82)/(p[3] + bs^6.4)
  
return(resp)}

predictpmfs <- function(p){
  
  contrastsC <- 10^(targetcontsdB/20)
  pmfout <- matrix(0,nrow=12,ncol=length(contrastsC))
  
  tr <- getmodelresp3inputs(p,contrastsC,0,0,0,0,0)
  nr <- getmodelresp3inputs(p,0,0,0,0,0,0)
  dprime <- (tr[1,] - nr[1,])/0.23
  pmfout[1,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,0,contrastsC,0,0,0)
  nr <- getmodelresp3inputs(p,0,0,0,0,0,0)
  dprime <- (tr[2,] - nr[2,])/0.23
  pmfout[2,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,0,0,0,contrastsC,0)
  nr <- getmodelresp3inputs(p,0,0,0,0,0,0)
  dprime <- (tr[3,] - nr[3,])/0.23
  pmfout[3,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,contrastsC,16,0,0,0,0)
  nr <- getmodelresp3inputs(p,0,16,0,0,0,0)
  dprime <- (tr[1,] - nr[1,])/0.23
  pmfout[4,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,16,contrastsC,0,0,0)
  nr <- getmodelresp3inputs(p,0,16,0,0,0,0)
  dprime <- (tr[2,] - nr[2,])/0.23
  pmfout[5,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,16,0,0,contrastsC,0)
  nr <- getmodelresp3inputs(p,0,16,0,0,0,0)
  dprime <- (tr[3,] - nr[3,])/0.23
  pmfout[6,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,contrastsC,0,0,64,0,0)
  nr <- getmodelresp3inputs(p,0,0,0,64,0,0)
  dprime <- (tr[1,] - nr[1,])/0.23
  pmfout[7,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,0,contrastsC,64,0,0)
  nr <- getmodelresp3inputs(p,0,0,0,64,0,0)
  dprime <- (tr[2,] - nr[2,])/0.23
  pmfout[8,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,0,0,64,contrastsC,0)
  nr <- getmodelresp3inputs(p,0,0,0,64,0,0)
  dprime <- (tr[3,] - nr[3,])/0.23
  pmfout[9,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,contrastsC,0,0,0,0,64)
  nr <- getmodelresp3inputs(p,0,0,0,0,0,64)
  dprime <- (tr[1,] - nr[1,])/0.23
  pmfout[10,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,0,contrastsC,0,0,64)
  nr <- getmodelresp3inputs(p,0,0,0,0,0,64)
  dprime <- (tr[2,] - nr[2,])/0.23
  pmfout[11,] <- 100*pnorm(dprime/sqrt(2))
  
  tr <- getmodelresp3inputs(p,0,0,0,0,contrastsC,64)
  nr <- getmodelresp3inputs(p,0,0,0,0,0,64)
  dprime <- (tr[3,] - nr[3,])/0.23
  pmfout[12,] <- 100*pnorm(dprime/sqrt(2)) 
  
return(pmfout)}

load('local/MCSdata.RData')
meanslopesMCS <- apply(slopematrix,c(2,3),mean)
meanslopesMCS <- round(10^(meanslopesMCS/20),digits=2)

load('local/MCSfit.RData')
draws <- extract(stanFit)
Zac <- mean(draws$Zacmu)
Zrg <- mean(draws$Zrgmu)
Zby <- mean(draws$Zbymu)
wAcR <- mean(draws$wAcRmu)
wAcB <- mean(draws$wAcBmu)
wRgA <- mean(draws$wRgAmu)
wRgB <- mean(draws$wRgBmu)
wByA <- mean(draws$wByAmu)
wByR <- mean(draws$wByRmu)

Zaclist <- draws$Zacmu
Zrglist <- draws$Zrgmu
Zbylist <- draws$Zbymu
wAcRlist <- draws$wAcRmu
wAcBlist <- draws$wAcBmu
wRgAlist <- draws$wRgAmu
wRgBlist <- draws$wRgBmu
wByAlist <- draws$wByAmu
wByRlist <- draws$wByRmu

if (processdata>0){

propcorr <- apply(MCSpropcorr,2:3,mean)
contrastsdB <- contrastsdB[1,,]

targetcontsdB <<- seq(-12,42,1)
allpmfpreds <- predictpmfs(c(Zac,Zrg,Zby,wAcR,wAcB,wRgA,wRgB,wByA,wByR))

ticklocsx <- seq(-12,42,6)
ticklabelsx <- c('1/4','1/2','1','2','4','8','16','32','64','128')
ticklocsy <- seq(0,100,25)
ticklabelsy <- ticklocsy

titlelist <- c('(a) Achromatic target','(b) R/G target','(c) B/Y target')

    pdf(paste0('Figures/MCSmodel.pdf'),width=12,height=8)
  
    par(mfrow=c(2,3))
    # layout(matrix(c(1,1,2,2,3,3,0,4,4,5,5,0),2,6,byrow=TRUE))
  
  for (cond in 1:3){

  par(pty="s")
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,42), ylim=c(0,100))  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)    # titles for axes
  title(ylab="Percent correct", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)
  title(main=titlelist[cond],cex.main=2)
  
  lines(c(-12,42),c(50,50),lty=2)

  lines(targetcontsdB,allpmfpreds[cond,],lwd=3)
  # lines(targetcontsdB,allmodelpreds[cond,],lwd=3)
  # points(contrastsdB[cond,],propcorr[cond,],pch=21,lwd=3,cex=2,bg='black')

  lines(targetcontsdB,allpmfpreds[cond+3,],lwd=3,lty=2)
  # lines(targetcontsdB,allmodelpreds[cond+3,],lwd=3,lty=2)
  # points(contrastsdB[cond+3,],propcorr[cond+3,],pch=21,lwd=3,cex=2,col='black',bg='white')

  lines(targetcontsdB,allpmfpreds[cond+6,],lwd=3,col='red')
  lines(targetcontsdB,allpmfpreds[cond+6,],lwd=3,col='green',lty=2)
  # lines(targetcontsdB,allmodelpreds[cond+6,],lwd=3,col='red')
  # lines(targetcontsdB,allmodelpreds[cond+6,],lwd=3,col='green',lty=2)
  # points(contrastsdB[cond+6,],propcorr[cond+6,],pch=21,lwd=3,cex=2,col='red',bg='green')

  lines(targetcontsdB,allpmfpreds[cond+9,],lwd=3,col='cornflowerblue')
  lines(targetcontsdB,allpmfpreds[cond+9,],lwd=3,col='gold',lty=2)     
  # lines(targetcontsdB,allmodelpreds[cond+9,],lwd=3,col='cornflowerblue')
  # lines(targetcontsdB,allmodelpreds[cond+9,],lwd=3,col='gold',lty=2)         
  # points(contrastsdB[cond+9,],propcorr[cond+9,],pch=21,lwd=3,cex=2,col='cornflowerblue',bg='gold')
  
  # text(18,10,paste(ntrials[1],'trials/level'),pos=4)
  
  # legend(-2,40,c('Target only','Achromatic mask','R/G mask','B/Y mask'), pch=21, col=c('black','black','red','cornflowerblue'),pt.cex=2,cex=1.5,pt.lwd=3,pt.bg=c('black','white','green','gold'),box.lwd=2)
  
  }
    
    
  par(pty="s")

plotlims <- c(0.5,3.5,0.5,3.5)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocs <- seq(1,3)    # locations of tick marks on x axis
ticklabels <- c('ACH','R/G','B/Y')
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabels, side = 1, at=ticklocs,line=0.5) 
mtext(text = ticklabels, side = 2, at=ticklocs, line=0.2, las=1) 
title(xlab="Target", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Mask", col.lab=rgb(0,0,0), line=2.5, cex.lab=1.5)
title(main='(d) Suppressive weights',cex.main=2)

weightmatrix <- matrix(1,nrow=3,ncol=3)
weightmatrix[1,2] <- wAcR
weightmatrix[1,3] <- wAcB
weightmatrix[2,1] <- wRgA
weightmatrix[2,3] <- wRgB
weightmatrix[3,1] <- wByA
weightmatrix[3,2] <- wByR

ramp3 <- colorRamp(c("white","darkorange"))  # create a ramp from one colour to another
colmatrix3 <- rgb(ramp3(seq(0, 1, length = 101)), max = 255)
image(1:3,1:3,weightmatrix,zlim=c(0,1),col=colmatrix3,add=TRUE,useRaster=FALSE)

contrastmatrix <- matrix(c(16,16,16,64,64,64,64,64,64),nrow=3,ncol=3)
denommatrix <- round(weightmatrix*contrastmatrix,digits=2)
weightmatrix <- round(weightmatrix,digits=2)

counter <- 0
for (x in 1:3){
  for (y in 1:3){
    text(x,y+0.1,weightmatrix[x,y],cex=1.6)
    text(x,y-0.1,paste0('(',denommatrix[x,y],')'),cex=1.6)
  }
}

    ticklocsx <- seq(-42,6,12)
    ticklabelsx <- c('1/128','1/32','1/8','1/2','2')
    
    plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-42,6), ylim=c(0,1))
    axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
    
    mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)
    title(main='(e) Posterior distributions',cex.main=2)
    title(xlab=expression(omega), col.lab=rgb(0,0,0), line=1.5, cex.lab=2.5)
    
    svals <- 20*log10(wAcRlist)
    a <- density(svals)
    a$y <- a$y/max(a$y)
    polygon(a$x,a$y,border=NA,col=addalpha('red',alpha=0.25))
    lines(a$x,a$y,col='black',lwd=2)

    svals <- 20*log10(wAcBlist)
    a <- density(svals)
    a$y <- a$y/max(a$y)
    polygon(a$x,a$y,border=NA,col=addalpha('cornflowerblue',alpha=0.25))
    lines(a$x,a$y,col='black',lwd=2)
    
    svals <- 20*log10(wRgAlist)
    a <- density(svals)
    a$y <- a$y/max(a$y)
    polygon(a$x,a$y,border=NA,col=addalpha('black',alpha=0.25))
    lines(a$x,a$y,col='red',lwd=2)

    svals <- 20*log10(wRgBlist)
    a <- density(svals)
    a$y <- a$y/max(a$y)
    polygon(a$x,a$y,border=NA,col=addalpha('cornflowerblue',alpha=0.25))
    lines(a$x,a$y,col='red',lwd=2)

    svals <- 20*log10(wByAlist)
    a <- density(svals)
    a$y <- a$y/max(a$y)
    polygon(a$x,a$y,border=NA,col=addalpha('black',alpha=0.25))
    lines(a$x,a$y,col='cornflowerblue',lwd=2)

    svals <- 20*log10(wByRlist)
    a <- density(svals)
    a$y <- a$y/max(a$y)
    polygon(a$x,a$y,border=NA,col=addalpha('red',alpha=0.25))
    lines(a$x,a$y,col='cornflowerblue',lwd=2)

    
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))  
    
  legend(0,1,c('Target only','Achromatic mask','R/G mask','B/Y mask'), lwd=3, col=c('black','black','red','cornflowerblue'),cex=1.9,box.lwd=2)

    legend(0,1,c('Target only','Achromatic mask','R/G mask','B/Y mask'), lty=2, lwd=3, col=c('black','white','green','gold'),cex=1.9,box.lwd=2)
 
    
  legend(0.05,0.5,c('Ach target, R/G mask','Ach target, B/Y mask','R/G target, Ach mask','R/G target, B/Y mask','B/Y target, Ach mask','B/Y target, R/G mask'), lwd=3, pch=22, col=c('black','black','red','red','cornflowerblue','cornflowerblue'),pt.bg=addalpha(c('red','cornflowerblue','black','cornflowerblue','black','red'),alpha=0.5),lty=NA,pt.cex=2,cex=1.5,box.lwd=2)
    
       
  dev.off()

  
}

```

```{r plotexampledips, include=FALSE}

if (processdata>0){

  window <- make_soft_window(256,256)
  grating <- mkgrating(256,3,90,0,1)
  stim1 <- (1+(0.5*window*grating))/2
  stim2 <- (1+(0.25*window*grating))/2
  stim3 <- (1+(0.75*window*grating))/2
  
pdf(paste0('Figures/exampledips.pdf'),width=12,height=6.5)
  
par(mfrow=c(1,2))

  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,4), ylim=c(0,4))  
    
ticklocsx <- seq(0.5,3.5,1)
ticklabelsx <- c('Left eye','Right eye','Left eye','Right eye')
ticklocsy <- c(0.5,1.38,1.62,2.5,3.5)
ticklabelsy <- c('Dichoptic','binocular','Half-','Binocular','Monocular')

  mtext(text = c('Pedestal only','Pedestal + Target'), cex=1.5, side = 3, at=c(1,3), line=0)  
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0)   
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0, las=1)


  polygon(c(0,4,4,0),c(0,0,4,4),border=NA,col=rgb(0.5,0.5,0.5))
  
  rasterImage(stim1,0.2,3.2,0.8,3.8)
  rasterImage(stim1,0.2,2.2,0.8,2.8)
  rasterImage(stim1,1.2,2.2,1.8,2.8)
  rasterImage(stim1,0.2,1.2,0.8,1.8)
  rasterImage(stim1,1.2,1.2,1.8,1.8)
  rasterImage(stim1,1.2,0.2,1.8,0.8)

  rasterImage(stim3,2.2,3.2,2.8,3.8)
  rasterImage(stim3,2.2,2.2,2.8,2.8)
  rasterImage(stim3,3.2,2.2,3.8,2.8)
  rasterImage(stim3,2.2,1.2,2.8,1.8)
  rasterImage(stim1,3.2,1.2,3.8,1.8)
  rasterImage(stim2,2.2,0.2,2.8,0.8)
  rasterImage(stim1,3.2,0.2,3.8,0.8)
   
  lines(c(0,4),c(0,0),lwd=3)
  lines(c(0,4),c(4,4),lwd=3)
  lines(c(0,0),c(0,4),lwd=3)
  lines(c(4,4),c(0,4),lwd=3)
  
  lines(c(0,4),c(1,1),lwd=1.5)
  lines(c(0,4),c(2,2),lwd=1.5)
  lines(c(0,4),c(3,3),lwd=1.5)
  
  lines(c(1,1),c(0,4),lwd=1.5)
  lines(c(2,2),c(0,4),lwd=3)
  lines(c(3,3),c(0,4),lwd=1.5)
  
  
collist <- c('red','blue','orange','darkgreen')

ticklocsx <- seq(-12,36,6)
ticklabelsx <- c('0','1/2','1','2','4','8','16','32','64')
ticklocsy <- seq(-12,36,6)
ticklabelsy <- c('1/4','1/2','1','2','4','8','16','32','64')

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-12,36))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

pedlist <- -12:36
pedlevelsC <- 10^(pedlist/20)
pedlevelsC[1] <- 0
exampledip <- array(0,dim=c(4,length(pedlist)))
  for (cond in 1:4){
    for (pedlev in 1:length(pedlist)){
      exampledip[cond,pedlev] <- discriminate(c(7.8,6.5,1.3,1,0.1,1,0.2),pedlevelsC[pedlev],cond)
    }
  }

exampledipdB <- 20*log10(exampledip)


for (cond in 1:4){
  lines(pedlist,exampledipdB[cond,],col=collist[cond],lwd=3)
}

legend(-12,36,c('Monocular','Binocular','Half-binocular','Dichoptic'),lwd=3,col=collist,box.lwd=2,cex=1.5)
  
  dev.off()
  
  
fundamentals <- read.csv('local/fundamentals.csv')
phosphors <- read.csv('local/phosphors.csv')  

achromatic <- (1+(window*grating))/2  
  
theta <- 135*pi/180
stimLMS <- c(cos(theta), sin(theta), 0)
rgbvals <- lms2rgb(phosphors,fundamentals,stimLMS)
rgbvals <- rgbvals/max(abs(rgbvals))

RGstim <- array(0,dim=c(256,256,3))
RGstim[,,1] <- (1+(rgbvals[1]*window*grating))/2 
RGstim[,,2] <- (1+(rgbvals[2]*window*grating))/2 
RGstim[,,3] <- (1+(rgbvals[3]*window*grating))/2 

theta <- 90*pi/180
stimLMS <- c(cos(theta), cos(theta), sin(theta))
rgbvals <- lms2rgb(phosphors,fundamentals,stimLMS)
rgbvals <- rgbvals/max(abs(rgbvals))

BYstim <- array(0,dim=c(256,256,3))
BYstim[,,1] <- (1+(rgbvals[1]*window*grating))/2 
BYstim[,,2] <- (1+(rgbvals[2]*window*grating))/2 
BYstim[,,3] <- (1+(rgbvals[3]*window*grating))/2 

t <- seq(0,1,length=9)
lummod <- sin(t*2*pi)
discstim <- array(0,dim=c(length(t),256,256))

for (i in 1:length(t)){
  discstim[i,,] <- (1+(window*lummod[i]))/2
}


pdf(paste0('Figures/examplestim.pdf'),width=8,height=8.5)

par(mar = c(4,1,1,1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,4), ylim=c(0,4))  
axis(1, at=seq(0,4,4/5), tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
mtext(text = seq(0,250,50), side = 1, at=seq(0,4,4/5), line=0)     
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   

rasterImage(achromatic,0,3,1,4)
rasterImage(RGstim,1.5,3,2.5,4)
rasterImage(BYstim,3,3,4,4)

text(0.5,2.8,'Achromatic grating',adj=0.5,cex=1.5)
text(2,2.8,'Red/green grating',adj=0.5,cex=1.5)
text(3.5,2.8,'Blue/yellow grating',adj=0.5,cex=1.5)
text(3,1.8,'Flickering disc (4Hz)',adj=0.5,cex=1.5)

for (i in 1:length(t)){
  rasterImage(discstim[i,,],0+(i-1)*(4/length(t)),2,0.4+(i-1)*(4/length(t)),2.4)
}

t <- seq(0,1,length=100)
lummod <- sin(t*2*pi)
lines(t*4,0.8*lummod+0.9,lwd=3)

dev.off()

}

```

```{r plotindividual, include=FALSE}

# plot individual participant data for appendices

if (processdata>0){
  
load('local/thresholddata.RData')
 
pdf('Figures/individualdippers.pdf',width=12,height=12)
par(mfrow=c(3,3))  

collist <- c('red','blue','orange','darkgreen')

ticklocsx <- seq(-12,36,6)
ticklabelsx <- c(0,0.5,1,2,4,8,16,32,64)
ticklocsy <- seq(-12,36,6)
ticklabelsy <- c(0.25,0.5,1,2,4,8,16,32,64)

for (p in 1:3){

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-12,39))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main=paste0('(',letters[(3*(p-1)+1)],')  P',p,': Achromatic'),cex.main=2)

pedcontrasts <- seq(-12,30,6)

for (cond in 1:4){
  lines(pedcontrasts,allthresh[p,1,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,allthresh[p,1,cond,],pch=16,col=collist[cond],cex=1.5)
}

if (p==1){legend(-12,36,c('Monocular','Binocular','Half-binocular','Dichoptic'),pch=16,col=collist,box.lwd=2,cex=1.5)}


par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-12,39))  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main=paste0('(',letters[(3*(p-1)+2)],')  P',p,': Red/Green'),cex.main=2)

pedcontrasts <- c(-12,seq(0,36,6))

for (cond in 1:4){
  lines(pedcontrasts,allthresh[p,3,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,allthresh[p,3,cond,],pch=16,col=collist[cond],cex=1.5)
}


par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-12,39))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main=paste0('(',letters[(3*(p-1)+3)],')  P',p,': Blue/Yellow'),cex.main=2)

for (cond in 1:4){
  lines(pedcontrasts,allthresh[p,2,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,allthresh[p,2,cond,],pch=16,col=collist[cond],cex=1.5)
}

}

dev.off()


load('local/MCSdata.RData')
meanslopesMCS <- apply(slopematrix,c(2,3),mean)
meanslopesMCS <- round(10^(meanslopesMCS/20),digits=2)
contrastsdB <- contrastsdB[1,,]

titlelist <- c('(a)  P1: Achromatic target','(b)  P1: R/G target','(c)  P1: B/Y target','(d)  P4: Achromatic target','(e)  P4: R/G target','(f)  P4: B/Y target','(g)  P5: Achromatic target','(h)  P5: R/G target','(i)  P5: B/Y target')

ticklocsx <- seq(-12,42,6)
ticklabelsx <- c('1/4','1/2','1','2','4','8','16','32','64','128')
ticklocsy <- seq(0,100,25)
ticklabelsy <- ticklocsy

pdf('Figures/individualMCS.pdf',width=12,height=12)
par(mfrow=c(3,3))  

for (p in 1:3){
  for (cond in 1:3){

  par(pty="s")
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,42), ylim=c(0,100))  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)    # titles for axes
  title(ylab="Percent correct", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)
  title(main=titlelist[3*(p-1)+cond],cex.main=2)
  
  lines(c(-12,42),c(50,50),lty=2)
  
  lines(contrastsdB[cond,],MCSpropcorr[p,cond,],lwd=3)
  points(contrastsdB[cond,],MCSpropcorr[p,cond,],pch=21,lwd=3,cex=2,bg='black')
  
  lines(contrastsdB[cond+3,],MCSpropcorr[p,cond+3,],lwd=3)
  points(contrastsdB[cond+3,],MCSpropcorr[p,cond+3,],pch=21,lwd=3,cex=2,col='black',bg='white')

  lines(contrastsdB[cond+6,],MCSpropcorr[p,cond+6,],lwd=3)
  points(contrastsdB[cond+6,],MCSpropcorr[p,cond+6,],pch=21,lwd=3,cex=2,col='red',bg='green')

  lines(contrastsdB[cond+9,],MCSpropcorr[p,cond+9,],lwd=3)
  points(contrastsdB[cond+9,],MCSpropcorr[p,cond+9,],pch=21,lwd=3,cex=2,col='cornflowerblue',bg='gold')
  
 
if (p==1 & cond==1){legend(-2,40,c('Target only','Achromatic mask','R/G mask','B/Y mask'), pch=21, col=c('black','black','red','cornflowerblue'),pt.cex=2,cex=1.5,pt.lwd=3,pt.bg=c('black','white','green','gold'),box.lwd=2)}
  
  }}

dev.off()


load('local/thresholddataDisc.RData')
 
pdf('Figures/individualdiscs.pdf',width=12,height=5)
par(mfrow=c(1,3))  

collist <- c('red','blue','orange','darkgreen')

ticklocsx <- seq(-12,36,6)
ticklabelsx <- c(0,0.5,1,2,4,8,16,32,64)
ticklocsy <- seq(-18,30,6)
ticklabelsy <- c(0.125,0.25,0.5,1,2,4,8,16,32)
pnos <- c(1,6,7)

for (p in 1:3){

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,36), ylim=c(-18,30))   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Pedestal contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)   
title(ylab="Threshold (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(main=paste0('(',letters[p],')  P', pnos[p] ,': Flickering disc'),cex.main=2)

pedcontrasts <- seq(-12,30,6)

for (cond in 1:4){
  lines(pedcontrasts,allthresh3[p,cond,],col=collist[cond],lwd=2)
  points(pedcontrasts,allthresh3[p,cond,],pch=16,col=collist[cond],cex=1.5)
}

if (p==1){legend(-12,30,c('Monocular','Binocular','Half-binocular','Dichoptic'),pch=16,col=collist,box.lwd=2,cex=1.5)}

}

dev.off()


}

```

# Abstract

# Introduction

The process by which the brain combines independent inputs is of fundamental importance for understanding sensory perception. Binocular vision is a useful test-case for determining the general principles involved in neural signal combination, as our brains typically combine the inputs from the left and right eyes to provide binocular single vision. In recent years our understanding has been facilitated by the development of binocular gain control models that provide a framework to interpret empirical data from multiple experimental paradigms and techniques, including psychophysics [@Meese2006], EEG [@Baker2017], fMRI [@Moradi2009] and pupillometry [@Segala2023]. However, the majority of this work has used achromatic (black and white) stimuli; we know comparatively little about how chromatic signals are combined binocularly, or about how signals in different ocular and chromatic channels interact. In this study we use psychophysical detection and discrimination paradigms to explore binocular interactions within and between the chromatic and achromatic pathways.

A useful framework for understanding binocular signal processing is the two-stage gain control model of binocular combination introduced by @Meese2006. This model features interocular suppression between monocular channels, followed by binocular summation. The model accounts well for the pattern of contrast discrimination ('dipper') functions for four distinct ocular configurations [see also @Georgeson2016], illustrated in @fig-exampledips. In the monocular condition, participants must discriminate between stimuli of two contrasts (a 'pedestal', and a 'pedestal plus target') that are both presented to one eye, whilst the other eye views mean luminance. Threshold is defined as the minimum target contrast required to make this judgement with 75% accuracy. The binocular condition is the same, except that the same stimuli are shown to both eyes. In the half-binocular condition the pedestal is shown to both eyes, but the target increment shown only to one eye. Finally, the dichoptic condition involves presenting the pedestal to one eye, and the target increment to the other eye. 

![Illustration of stimulus conditions (left) and example dipper functions (right).](Figures/exampledips.pdf){#fig-exampledips}

The detailed pattern of thresholds across these four conditions is complex, and for achromatic stimuli has several distinctive features that have been replicated in multiple studies. At low pedestal contrasts, the binocular condition yields lower thresholds than the monocular condition; this result is attributed to physiological binocular summation by neurons responsive to signals from both eyes [@Baker2018; @Campbell1965]. However at high pedestal contrasts the 'handle' regions of the dipper functions for these conditions converge: a consequence of interocular suppression compensating for the increased excitation during binocular stimulation [@Legge1984; @Maehara2005]. The half-binocular condition avoids confounding the number of eyes seeing the target with the number of eyes seeing the pedestal [@Meese2006]. The pedestal is always binocular in this condition, whereas the target increment is monocular, and thresholds are consistently higher than in the binocular condition across the full range of pedestal contrasts. This demonstrates that binocular summation occurs across the full contrast range, when the pedestal ocularity is appropriately controlled. Finally, the dichoptic condition produces extremely strong masking of the target, such that when the pedestal is visible, the target must equal or exceed its contrast in order to be detectable [@Legge1979; @Maehara2005; @Baker2007b]. The characteristic pattern of dipper functions is well-described by the gain control model of @Meese2006 for achromatic stimuli.

At the output of the human retina, cone responses are split into three distinct pathways. The sum of long- and medium-wavelength cone outputs (L+M) transmits luminance information, and is likely responsible for the binocular combination effects previously studied using achromatic stimuli (see above). The difference of long- and medium-wavelength cone outputs (L-M) is responsive to chromatic stimuli modulating along a red/green axis in colour space. Finally the short wavelength cone outputs (S-(L+M)) code chromatic stimuli modulating along a blue/yellow axis. There has not yet been a detailed investigation of binocular contrast discrimination in either of these chromatic pathways, however there is reason to believe they may differ from the achromatic pathway. At detection threshold, binocular summation is greater for chromatic versus achromatic stimuli [@Simmons2005], implying a more linear initial stage of processing. For cross-orientation masking, there are differences in the magnitude of masking between chromatic (red/green) and achromatic stimuli [@Kim2013; @Medina2009], as well as differences in their temporal dynamics [@Kim2015]. There are also interactions between chromatic and achromatic pathways both within [@Chen2000] and between [@Mullen2014; @Kingdom2015] the eyes, yet these have not been fully explored for arrangements where the target and mask have the same orientation. Finally, the neurophysiological underpinnings of colour vision are distinct from those of the achromatic system. In primary visual cortex (V1), chromatic signals are processed in 'blob' regions that are revealed by cytochrome oxidase staining [@Horton1981]. The blob regions appear to be largely monocular [@Livingstone1984], suggesting that binocular combination for chromatic stimuli might occur later than for achromatic stimuli, and perhaps be subject to different constraints.

A further property of 'blob' regions is that they are less strongly orientation-tuned than other regions of V1 [@Horton1981; @Livingstone1984], and biased towards low spatial frequencies [@Edwards1995; @Tootell1988]. Our recent work has investigated binocular combination for flickering discs of luminance, which are DC-balanced across time [@Segala2023]. Steady-state EEG responses from early visual cortex and psychophysical contrast matching data were both consistent with weak interocular suppression when using this stimulus arrangement. This is very different from the 'ocularity invariance' that is well-established when using DC-balanced periodic stimuli such as sine-wave gratings, and implies strong interocular suppression [@Meese2006; @Baker2017; @Moradi2009]. There is additional psychophysical evidence from matching studies that binocular combination can be close to linear for luminance increments [@Levelt1965; @Anstis1998], particularly against a dark background [@Baker2012]. Both structural and functional data therefore imply that binocular combination may differ between spatial and temporal contrast.

The main aim of the present study is to characterise binocular signal combination for chromatic stimuli, and for temporal modulations of luminance. We also aimed to investigate interocular suppression between chromatic and achromatic pathways. We therefore preregistered a series of psychophysical experiments (see: [https://osf.io/3vdga/](https://osf.io/3vdga/)). In Experiment 1 we replicate the four key pedestal masking conditions of @Meese2006 described above for achromatic grating stimuli, and extend this to both red/green and blue/yellow isoluminant chromatic stimuli. In Experiment 2 we explore dichoptic masking within and between these stimuli. Experiment 3 repeats the achromatic condition from the first experiment, but using a temporally modulated disc rather than sine-wave gratings. We take a Bayesian approach to data analysis and modelling; by fitting a hierarchical version of the two-stage gain control model [@Meese2006] we compare posterior parameter distributions to understand how model parameters such as the weight of interocular suppression vary across visual pathways.

# Materials & Methods

## Participants

All experiments were completed by the first author (DHB) and two additional participants, who differed for each experiment. Participants had no known abnormalities of binocular vision. Written informed consent was obtained before data collection began, and all procedures were approved by the ethics committee of the Department of Psychology at the University of York (ID number 2202).

## Apparatus & stimuli

In Experiments 1 and 2, the stimuli were horizontal sinusoidal gratings with a spatial frequency of 1c/deg (see examples in @fig-examplestim). The gratings were windowed by a raised cosine envelope with a diameter of 3 degrees. Spatial phase, relative to a central fixation cross, was randomised on each trial across the four cardinal phases. In the achromatic conditions, the sine-wave modulated all three monitor colour channels equally (red, green and blue). In the L-M condition, we generated isoluminant stimuli for each participant (see Procedures) designed to maximise contrast between L and M cones, whilst keeping S cone activity constant. In the S-(L+M) condition, the isoluminant stimuli maximised S-cone contrast. Stimuli were converted from cone space to monitor RGB coordinates using the monitor spectral readings and the Stockman-Sharpe 2 degree cone fundamentals [@Stockman2000]. The stimuli in Experiment 3 were temporal modulations of luminance applied to a disc made using the same raised cosine envelope as described above, but with no further spatial modulation. The stimuli counterphase flickered sinusoidally at 4Hz (see examples in the lower portion of @fig-examplestim). In all experiments, we displayed a binocular fusion lock, consisting of three concentric rings of small square elements with random colour. A black central fixation cross was also displayed throughout.

![Example stimuli. Upper row shows grating stimuli used in Experiments 1 and 2. Lower row shows one cycle of sinusoidal flicker applied to a uniform disc. Note that the rendering of all stimuli will depend on the device used to display or print this image, and so the chromatic stimuli are unlikely to appear isoluminant, and there may be additional luminance nonlinearities that were not present in the stimuli displayed during the experiments.](Figures/examplestim.pdf){#fig-examplestim width=50%}

All stimuli were presented on an Iiyama VisionMaster Pro 510 CRT monitor, with a refresh rate of 100Hz, and a resolution of 1024 x 768 pixels. The display was driven by a ViSaGe MkII stimulus generator (Cambridge Research Systems Ltd., Kent, UK) running in 42-bit colour mode (14 bits per colour channel). We presented stimuli to the left and right eyes independently using a four-mirror stereoscope with front-silvered mirrors. The display was luminance calibrated using a ColourCal photometer (Cambridge Research Systems), and gamma corrected by fitting a four-parameter gamma function to the output of each CRT gun. The maximum luminance was 87 cd/m$^2$. We also measured the spectral output of each phosphor using a Jaz spectroradiometer (Ocean Insight, Florida), and used these measurements to convert between LMS (cone) space and the monitor RGB coordinates.

For convenience, we express stimulus contrast as a percentage of the maximum possible contrast that could be displayed on our system. For achromatic stimuli, the maximum contrast is 1, so this is equivalent to the standard Michelson contrast expressed as a percentage. For the isoluminant chromatic stimuli, the maximum displayable L-M (red/green) cone contrast was 0.1, and the maximum displayable S-(L+M) (blue/yellow) cone contrast was 0.88. An L-M threshold of 50\% therefore corresponds to a cone contrast of $0.5\times0.1 = 0.05$, and an S-(L+M) threshold of 50\% corresponds to a cone contrast of $0.5\times0.88 = 0.44$. This means that the threshold values reported throughout can be converted to cone contrast by a straightforward multiplicative transform.

## Procedure

All experiments took place in a darkened room. Participants placed their heads in a chin rest mounted on a height-adjustable table, to which the stereoscope was also attached. The total optical viewing distance (including the light path through the mirrors) was 104cm, at which distance 1 degree of visual angle encompassed 48 pixels on the monitor.

Before beginning primary data collection, each participant in Experiments 1 and 2 completed an isoluminance adjustment task. Grating stimuli were presented that counterphase flickered at 5Hz, defined about either the L-M or S-(L+M) plane in cone space. Participants used a trackball to dynamically adjust the colour angle of the stimulus to minimise the percept of flicker. Each participant completed ten such trials for each colour plane, and the average angle across repetition was taken as the isoluminant point, and used to generate stimuli for the main experiment for that participant. Settings were very similar across participants for the S-(L+M) direction, and  somewhat more heterogeneous for the L-M direction (see @fig-isofig).

![Isoluminance settings from all participants in Experiments 1 and 2. Panel (a) shows red/green and panel (b) shows blue/yellow settings that were subsequently used to generate stimuli in the main experiments. Within each panel, solid lines show the mean settings for each participant, and black curves show the range of possible stimuli displayed during the adjustment task.](Figures/isosettings.pdf){#fig-isofig}

In Experiment 1, participants completed a two-interval-forced-choice (2IFC) contrast discrimination task. Stimuli were presented for 200ms, with an interstimulus interval of 400ms. Each interval was indicated by an auditory beep, and participants made their responses using a two-button trackball. Correct responses were followed by a high pitched tone, and incorrect responses by a low pitched tone. Each block of the experiment tested a single pedestal contrast level, and lasted around 12 minutes. On each trial the target contrast level was determined by a 3-down-1-up staircase procedure. There were 8 interleaved staircases in total; four stimulus arrangements (see @fig-exampledips) combined factorially with two target eye assignments. Each pedestal contrast was repeated 3 times by each participant, and the block order was randomised. The experiment lasted around 4 hours per participant for each chromatic condition, and took place over the course of several weeks. In total, the experiment consisted of `r nrow(ex1data)` trials (pooled across participants).

In Experiment 2, participants completed a 2IFC dichoptic masking task. The stimuli and trial protocol were the same as for Experiment 1, except that the target contrast was chosen from a set of 10 possible values, determined in advance based on the data of Experiment 1. There were 12 possible conditions: baseline detection thresholds for achromatic, red/green and blue/yellow stimuli, and the nine possible factorial pairings obtained by assigning these conditions to be target and dichoptic mask stimuli. Mask contrasts were chosen to be approximately 16 times their (monocular) detection threshold, based on the data from Experiment 1. As a percentage of the maximum displayable contrast, these were 16% for achromatic stimuli, and 64% for both of the chromatic stimuli. Each block of the experiment tested a single condition, and consisted of 200 trials. A high contrast example of the target stimulus was displayed at the foot of the screen throughout, so that there was no ambiguity about the target identity on a given block. Participants completed 10 repetitions of each condition (120 blocks of ~6 minutes each), lasting around 12 hours, for a total of `r nrow(ex2data)` trials (pooled across participants).

In Experiment 3, the achromatic conditions from Experiment 1 were repeated using a flickering disc stimulus. The stimulus counterphase flickered at 4Hz, and was presented for 500ms (i.e. 2 full cycles of the temporal modulation). All other procedures were the same as for Experiment 1, and the experiment comprised a total of `r nrow(ex3data)` trials (pooled across participants).

## Data analysis and computational modelling

Psychometric functions from each experiment were fit using \emph{psignifit} 4 to estimate threshold and slope parameters via a Bayesian numerical integration method [@Schutt2016]. A cumulative Gaussian was used as the underlying function, and we converted the slope estimates ($\sigma$ parameters from the fitted Gaussians) to equivalent Weibull $\beta$ values using the approximation $\beta = 10.3/\sigma$.

The two stage model of @Meese2006 was fit to the threshold data from Experiments 1 and 3 using a simplex algorithm to minimise the error between the model and data. The model is defined by a series of equations:

\begin{equation}
Stage1_L = \frac{C_L^m}{S + C_L + \omega C_R},
\end{equation}

\begin{equation}
Stage1_R = \frac{C_L^m}{S + C_R + \omega C_L},
\end{equation}

\begin{equation}
binsum = Stage1_L + Stage1_R,
\end{equation}

\begin{equation}
Stage2 = \frac{binsum^p}{Z + binsum^q},
\end{equation}

where $C_L$ and $C_R$ are the contrasts displayed to the left and right eyes, and $m$, $S$, $\omega$, $p$, $q$ and $Z$ are free parameters in the model. A further free parameter, $k$, represents additive internal noise, and is used to convert the model outputs to either d-prime or threshold values (note that in the original model specification [@Meese2006] this parameter was called $\sigma$, but we use the $k$ symbol here to avoid confusion with the standard deviation of the cumulative Gaussian used when fitting the psychometric functions to derive thresholds). Thresholds are defined by iteratively adjusting the target contrast until the following equality is satisfied:

\begin{equation}
Stage2_{target+pedestal} - Stage2_{pedestal} = k,
\end{equation}

and d-prime for a single target level is defined as:

\begin{equation}
d' = \frac{Stage2_{target+pedestal} - Stage2_{pedestal}}{k}.
\end{equation}

We ran the simplex algorithm from `r ntotalsimplexfits` random starting vectors for each data set, and chose the solution for each data set that gave the smallest RMS error.

We also implemented a Bayesian hierarchical version of the model using the Stan language [@Carpenter2017]. This used a binomial generator function to model the proportion correct data at each target level, and was fit simultaneously to all participants for a given experiment, but separately for each chromatic condition of Experiment 1, and the flickering disc data from Experiment 3 (i.e. four fits in total, as for the simplex fitting). Prior distributions were Gaussian, with means determined from published values (see first row of @tbl-parametertable). This modelling primarily focuses on examining posterior parameter distributions, rather than a model comparison approach. We generated over 1 million posterior samples for the model, and retained 10\% of them for plotting.

Finally, we adapted the two stage model to include parallel pathways to process achromatic, red/green and blue/yellow stimuli, that mutually suppress each other. We added additional suppressive terms at the first (monocular) stage of the model, for example:

\begin{equation}
ACStage1_L = \frac{AC_L^m}{S + AC_L + \omega_A AC_R + \omega_R RG_R + \omega_B BY_R},
\end{equation}

where *AC* represents the achromatic contrast, *RG* represents the red/green contrast, *BY* represents the blue/yellow contrast, and $\omega_A$, $\omega_R$ and $\omega_B$ are the accompanying weights of interocular suppression. There is an equivalent expression for the right eye, and for each of the two isoluminant chromatic pathways. To simplify the model, and avoid free parameters that are poorly constrained by the data, we fixed several parameters at the average values from the fits from Experiment 1 (@tbl-parametertable), such that $p=7.82$, $q=6.4$, $m=1.21$, $S=1.03$ and $k=0.23$. We additionally fixed the within-mechanism weight of interocular suppression ($\omega$) at 1. This left 9 free parameters: a $Z$ parameter for each mechanism, and six cross-mechanism weights of interocular suppression. These parameters were again estimated within a Bayesian hierarchical framework, using the trial-wise data from Experiment 2. Note that the model as specified does not currently include monocular suppression between different pathways, as we did not collect any data for these conditions. Previous work [@Chen2000] has measured such interactions, and they could in principle be incorporated into the denominator of either stage 1 or stage 2 in the model.

## Open science practices

All experimental code, raw data and analysis scripts are available at: https://osf.io/3vdga/. The linked GitHub repository also contains a fully reproducible version of the manuscript. Note that we deviated slightly from the planned preregistration, in that we did not collect data for chromatic flickering discs, or for the cross-pathway dichoptic experiment using disc stimuli. This is because the grating data from Experiments 1 and 2, and the achromatic disc data from Experiment 3, were sufficient to address the questions we had hoped to answer from these experiments.

# Results

## Experiment 1

```{r dipregressions, echo=FALSE}

regdata <- NULL
regdata$thd <- meanthresh[1,2,5:8]
regdata$ped <- seq(12,30,6)
regdata <- as.data.frame(regdata)
binregACH <- lm(thd ~ ped, data=regdata)

regdata <- NULL
regdata$thd <- meanthresh[3,2,5:8]
regdata$ped <- seq(12,30,6)
regdata <- as.data.frame(regdata)
binregRG <- lm(thd ~ ped, data=regdata)

regdata <- NULL
regdata$thd <- meanthresh[2,2,5:8]
regdata$ped <- seq(12,30,6)
regdata <- as.data.frame(regdata)
binregBY <- lm(thd ~ ped, data=regdata)

regdata <- NULL
regdata$thd <- meanthresh[1,4,5:8]
regdata$ped <- seq(12,30,6)
regdata <- as.data.frame(regdata)
dichregACH <- lm(thd ~ ped, data=regdata)

regdata <- NULL
regdata$thd <- meanthresh[3,4,5:8]
regdata$ped <- seq(12,30,6)
regdata <- as.data.frame(regdata)
dichregRG <- lm(thd ~ ped, data=regdata)

regdata <- NULL
regdata$thd <- meanthresh[2,4,5:8]
regdata$ped <- seq(12,30,6)
regdata <- as.data.frame(regdata)
dichregBY <- lm(thd ~ ped, data=regdata)

```

Dipper functions from Experiment 1 are displayed in the upper row of @fig-dipperfig. Panel (a) shows the achromatic results, which replicate the key features from previous work. At detection threshold, binocular summation was a factor of `r round(10^(summation[1]/20),digits=2)` (`r round(summation[1],digits=2)`dB), within the range ($\sqrt{2}$ to 2) consistent with previous reports [@Baker2018]. Pedestal masking functions followed the typical 'dipper' shape in all conditions, with a region of facilitation at low pedestal contrasts, and masking at higher contrasts. The monocular and binocular dipper handles converge at high contrasts, whereas the half-binocular thresholds remain above the binocular thresholds across the full range of pedestal contrasts. The dichoptic condition produced very high thresholds, with the rising portion of the dipper having a slope around 1 (regression slope of `r round(dichregACH$coefficients[2], digits=2)` in log (dB) units, calculated across the highest 4 pedestal contrasts).

![Dipper functions and psychometric slopes from Experiment 1, averaged across three participants. Panels (a-c) show threshold data, and panels (d-f) represent the slope of the psychometric function expressed in Weibull $\beta$ units. Error bars give 1SE across participants. Note that contrast values are expressed as a percentage of the maximum displayable contrast (see Procedures for details). Curves in panels (a-c) show the best fitting models, optimized using a simplex algorithm (described in section 4.4), and RMSE values give the root mean square errors of the fits.](Figures/dipperssimplex.pdf){#fig-dipperfig}

A similar pattern of results was observed for both the red/green and blue/yellow isoluminant stimuli (see [@fig-dipperfig]b,c). Summation at threshold was a factor of `r round(10^(summation[3]/20),digits=2)` (`r round(summation[3],digits=2)`dB) for the red/green targets, and a factor of `r round(10^(summation[2]/20),digits=2)` (`r round(summation[2],digits=2)`dB) for the blue/yellow targets, and so was marginally higher than for achromatic stimuli. The general character of the dipper functions was largely consistent with the achromatic results, though we observed shallower facilitation and weaker masking, especially for the blue/yellow stimuli. For example, the strongest facilitation in the binocular condition for achromatic stimuli was a factor of `r round(10^((meanthresh[1,2,1]-meanthresh[1,2,3])/20),digits=2)`, whereas it reduced to a factor of `r round(10^((meanthresh[3,2,1]-meanthresh[3,2,3])/20),digits=2)` for red/green stimuli and `r round(10^((meanthresh[2,2,1]-meanthresh[2,2,3])/20),digits=2)` for blue/yellow stimuli. The slope of the binocular dipper handle was `r round(binregACH$coefficients[2], digits=2)` for achromatic stimuli, `r round(binregRG$coefficients[2], digits=2)` for red/green stimuli, and `r round(binregBY$coefficients[2], digits=2)` for blue/yellow stimuli. Dichoptic masking remained as strong for the chromatic conditions as for the achromatic stimuli (regression slopes of `r round(dichregRG$coefficients[2], digits=2)` for red/green and `r round(dichregBY$coefficients[2], digits=2)` for blue/yellow). The pattern of results for individual participants was consistent with the group averages, as shown in [@fig-individualdippers].

Following @Meese2006, we also inspected the slope of the psychometric function for each condition (see [@fig-dipperfig]d-f). At detection threshold, slopes were relatively steep for all stimuli, with $\beta$ values around 4. As pedestal contrasts increased, slopes linearized and reduced to around $\beta=1.3$ [@Foley1981; @Meese2006], and remained shallow at high pedestal contrasts. The exception to this was the dichoptic condition, where slopes became extremely steep at high dichoptic mask contrasts, consistent with previous observations [@Meese2006; @Baker2013]. This was clear for all three data sets, with slope values in the range $4 < \beta < 8$. However, we observe that slope estimates are more variable than threshold estimates (note the large error bars), particularly when using adaptive staircases, which deploy the majority of trials close to threshold. Our second experiment therefore investigated the slope of the psychometric function in more detail for dichoptic masking using the method of constant stimuli.

## Experiment 2

In Experiment 2 we focussed on the dichoptic condition at a single mask contrast, and measured full psychometric functions using the method of constant stimuli for all factorial pairings of target and mask chromaticity. The pooled results across three participants are shown in [@fig-MCSfig]a-c, and results for individual participants are available in [@fig-individualMCS]. All conditions produced monotonically increasing psychometric functions (panels a-c), but the extent of masking was highly dependent on the relationship between the target and mask chromaticity. [@fig-MCSfig]d-f shows a two-dimensional representation of individual threshold and slope estimates (points), as well as the posterior density estimates for fits to the pooled data (ellipses). The results are consistent between participants, and at the group level, and show that the presence of a mask has a strong effect on thresholds.

![Summary of data from Experiment 2. Panels (a-c) show psychometric functions for each condition, pooled across participants (600 trials per target contrast level). Panels (d-f) show threshold and slope estimates for individual participants (points) and the boundary of the posterior density estimates for fits to the pooled data (ellipses). Panel (g) shows the average threshold elevation factor for each combination of target and mask stimulus. Panel (h) shows the geometric mean psychometric slope value for each masking condition in Weibull $\beta$ units.](Figures/MCSdata.pdf){#fig-MCSfig}

Threshold elevation was greatest when the target and mask had the same chromaticity - notice that the psychometric function is shifted furthest to the right for the achromatic target with an achromatic mask (white and black circles in [@fig-MCSfig]a), for the red/green target with a red/green mask (red and green circles in [@fig-MCSfig]b), and for the blue/yellow target with a blue/yellow mask (blue and yellow circles in [@fig-MCSfig]c). Masking was weakest between achromatic masks/targets and chromatic masks/targets. Finally there was an intermediate level of masking between red/green and blue/yellow stimuli. This is summarised in [@fig-MCSfig]g, which represents threshold elevation for each combination of target and mask chromaticity. Note that the positive diagonal exhibits the highest values, and represents threshold elevation between targets and masks of the same chromaticity.

We also calculated the slope of the psychometric function for each condition, in equivalent Weibull $\beta$ units. In the absence of a mask, the average slope was $\beta$ = `r round(10^(mean(detslopes)/20),digits=2)`, which is typical for contrast detection tasks [@Wallis2013]. Slopes became substantially steeper when the dichoptic mask matched the target in chromaticity (average $\beta$ = `r round(10^(mean(log10(c(meanslopesMCS[1,1],meanslopesMCS[2,2],meanslopesMCS[3,3])))),digits=2)`). These 'super-steep' psychometric functions for dichoptic pedestal masking have been reported previously [@Meese2006; @Baker2013], and are observed for the first time here using chromatic stimuli (see diagonal values in [@fig-MCSfig]h, and also [@fig-dipperfig]d-f). However we did not see such markedly steep functions for any of the cross-chromaticity masking conditions (average $\beta$ = `r round(10^(mean(log10(c(meanslopesMCS[1,2],meanslopesMCS[1,3],meanslopesMCS[2,1],meanslopesMCS[2,3],meanslopesMCS[3,1],meanslopesMCS[3,2])))),digits=2)` for the off-diagonal values).

## Experiment 3

In our final experiment, we again measured dipper functions, but this time for a temporally modulating luminance disc. This was motivated by our recent work [@Segala2023] that appeared to show increased binocular facilitation and reduced interocular suppression for flickering disc stimuli (relative to gratings), measured using EEG and a psychophysical matching paradigm. The pattern of dipper functions for a 4Hz flickering disc (see [@fig-discdata]a) was very similar to that observed for achromatic gratings (see [@fig-dipperfig]a), and the binocular summation ratio at threshold was also similar (a factor of `r round(10^(summationDisc/20),digits=2)` for discs, vs `r round(10^(summation[1]/20),digits=2)` for gratings). Threshold data for individual participants are shown in [@fig-individualdiscs]. We also found a similar pattern of psychometric slope values ([@fig-discdata]b) as we had for gratings, though we note that the dichoptic condition did not produce the 'super-steep' psychometric functions we had observed in Experiments 1 & 2. Nevertheless, the dichoptic slopes are somewhat above those of the other pedestal arrangements at high contrasts.

![Thresholds for the flickering disc experiment. Plotting conventions mirror those in Figure 4.](Figures/discdata.pdf){#fig-discdata width=80%}

## Computational modelling

```{r setuptable}
#| echo: false

load('local/simplexfits.RData')

tableparams <- matrix(0,nrow=11,ncol=8)

tableparams[1,1:7] <- c(7.99,6.59,1.28,0.99,0.08,1,0.19)
tableparams[3,1:7] <- allp[1,]
tableparams[4,1:7] <- allp[2,]
tableparams[5,1:7] <- allp[3,]
tableparams[6,1:7] <- allp[4,]
tableparams[3:6,8] <- allrms

tableparams[8:11,1:7] <- allstanparams

tableparams <- format(round(tableparams,digits=2),nsmall=2)

tableparams <- data.frame(tableparams)

tableparams$Model <- c('Meese et al. (2006)','Simplex fits','Achromatic gratings','Red/green gratings','Blue/yellow gratings','Flickering discs','Bayesian model','Achromatic gratings','Red/green gratings','Blue/yellow gratings','Flickering discs')

colnames(tableparams) <- c("p", "q", "m", "S", "Z", "$\\omega$", "k", "RMSE", "Model fit")
tableparams$RMSE <- paste(tableparams$RMSE,'dB')
tableparams <- tableparams[,c(9,1,2,3,4,5,6,7,8)]

tableparams[c(1,2,7:11),9] <- ' '
tableparams[c(2,7),2:9] <- ' '
```

```{r}
#| label: tbl-parametertable
#| echo: false
#| tbl-cap: 'Summary of fitted model parameters. The top row gives the best fitting parameters from the study of Meese et al. (2006). The second section shows the best fitting parameters from simplex fits to the averaged thresholds for each experiment. The final rows show the posterior parameter estimates from the Bayesian model, fitted to each data set from Experiments 1 and 3.'

knitr::kable(tableparams, align='lrrrrrrrr', booktabs = TRUE, linesep='',escape = FALSE) %>%
row_spec(c(1,6),hline_after=T) %>% row_spec(0,italic=T) %>% row_spec(c(0,2,7),bold=T)

```

For consistency with previous work, we initially performed least-squares fits of the two-stage model [@Meese2006] for each of the chromaticity experiments, and the flickering disc experiment (7 free parameters per fit). The best model fits are shown by the curves in @fig-dipperfig & @fig-discdata, and provide an excellent description of the data, with RMS errors between `r round(min(allrms),digits=2)` and `r round(max(allrms),digits=2)`dB. Best fitting parameters are shown in the 'Simplex fits' section of @tbl-parametertable. We note that in previous work, the weight of interocular suppression ($\omega$ in the model) is implicitly fixed at 1. Here we allowed it to vary, but it still received a value of exactly 1 in all of our grating conditions, and slightly below 1 (`r round(allp[4,6],digits=2)`) for our flickering discs. The exponent values (*p* and *q*) for the red/green gratings are rather different from those of the other conditions. In previous work [@Meese2006] the second stage gain control nonlinearity (Equation 4) does typically have quite substantial exponent values, which balance the relatively mild nonlinearity at the first stage, and produce a compressive transducer that results in contrast masking (the handle of the dipper). The high value of *p* = `r round(allp[2,1], digits=2)` is therefore likely to be compensating for the low value of *m* = `r round(allp[2,3], digits=2)` at stage one, but may well represent the combination of several successive stages of nonlinearity, and perhaps also other phenomena such as uncertainty [@Pelli1985].

We additionally implemented a hierarchical Bayesian version of the model in order to estimate full posterior parameter distributions. This model was fit simultaneously to the full trial-by-trial data from all participants who participated in a given experiment (i.e. the model was fitted separately to each of the four dipper data sets). [@fig-bayesianmodel]a-d summarises the model behaviour, which displays the same pattern of dipper functions as we found empirically. Mean posterior parameter values are given in the lower rows of @tbl-parametertable. These correspond quite closely to the parameters from the simplex fitting and the original @Meese2006 parameters (reproduced in the first row of the table for reference). The panels in the right and upper margins of [@fig-bayesianmodel] show posterior distributions for each model parameter. Note in particular that the posterior distribution for the weight of interocular suppression ($\omega$, top right panel) overlaps 1 for each experiment, consistent with the strong dichoptic masking observed in the threshold data. We note that the distribution for $\omega$ in the flickering disc condition is somewhat lower than for the other three data sets. However this difference is not meaningful according to criteria such as comparing the 95% credible intervals of the distribution to a value of $\omega=1$.

![Model predictions (a-d) and posterior parameters (top and right margin plots) for the hierarchical Bayesian model. Thick lines in panels (a-d) show curves generated from the mean posterior parameter estimates. The probability density functions in the margin plots are peak-normalized, and shown for each of the four data sets in different colours (see legend in upper left plot). Distributions were generated from 1000000 samples per data set, using a Markov Chain Monte Carlo sampling algorithm. Note the logarithmic x-axis for all posterior plots.](Figures/stanoutput.pdf){#fig-bayesianmodel}

Finally we fitted an extended model, that included interocular suppression between the different pathways, to the data of Experiment 2. [@fig-MCSmodel] shows the model curves (panels a-c), which correspond closely to the data in [@fig-MCSfig]. One striking discrepancy is that the model predicts a region of negative d-prime for the case where the target and dichoptic mask have the same chromaticity (see the curved regions below 50\% correct). This feature was not generally present in our data, though it can be observed for one participant in [@fig-individualMCS]b,c. Our previous work [@Baker2013] has found evidence for this phenomenon (termed 'swan functions'), but it generally requires very high mask contrasts to be measurable empirically, and there may also be some individual differences; both factors might explain its absence here.

[@fig-MCSmodel]d,e shows the model estimates for the weight of interocular suppression in each combination of target and mask chromaticity. Although the weights might appear to indicate that (excluding within-mechanism effects) suppression is strongest between blue/yellow targets and achromatic masks (a weight of 0.56), this is somewhat complicated by the differences in sensitivity and mask contrast between conditions. We selected mask contrasts that were approximately equal multiples ($16\times$) of their own detection thresholds, based on the data of Experiment 1 ([@fig-dipperfig]a-c). However the modelling expressed these contrasts as a percentage of the maximum contrast that it was possible to display on the monitor (see Procedures). The values in brackets in [@fig-MCSmodel]d indicate the overall suppressive term on the denominator, calculated by multiplying the mask contrast by the fitted weight. These values indicate that the strongest suppression is instead between red/green targets and blue/yellow masks, consistent with the threshold elevation observed empirically ([@fig-MCSfig]g). In principle it would be possible to repeat this modelling using either cone contrast values, or contrast expressed relative to detection threshold, which would require re-fitting the model.

![Summary of the model fit to the data of Experiment 2. Panels (a-c) show model psychometric functions in the same format as those in Figure 5. Panel (d) shows the fitted suppressive weights ($\omega$ values), with values in brackets indicating the combined suppressive denominator term calculated by multiplying together the suppressive weight and the dichoptic mask contrast. Panel (e) shows the posterior distributions for each weight parameter. The lower right plot gives the legends for the upper row (top) and the posterior distributions in panel (e).](Figures/MCSmodel.pdf){#fig-MCSmodel}

# Discussion

Across three psychophysical experiments, we have demonstrated that:

- Binocular combination of isoluminant chromatic stimuli is similar to that for achromatic stimuli
- Interocular suppression is strongest within a post-retinal pathway, and weakest between achromatic and chromatic pathways
- Binocular combination occurs similarly for spatial and temporal luminance modulations

We now discuss the relationship to previous work, and consider the likely physiological substrates of these effects.

## Summation at threshold

Estimates of the binocular summation ratio at threshold fell within the range $\sqrt{2}$ to 2 for all four data sets. Consistent with previous reports [@Simmons2005], summation was slightly higher for chromatic versus achromatic stimuli, but fell short of perfect linear summation (a ratio of 2). In our model, summation at threshold is determined by the exponent at the first gain control stage (the *m* parameter in Equations 1 & 2). The summation ratio can be approximated by $2^{1/m}$ [see Figure 9 of @Baker2012], such that an exponent of $m=1$ produces a ratio of 2, and an exponent of $m = 2$ produces a ratio of $\sqrt{2}$. Both the simplex and Bayesian model fits (see @tbl-parametertable) generated parameter estimates in the range $1 < m < 1.4$, consistent with the high levels of summation observed empirically.

## Interocular suppression

The weight of interocular suppression is represented by the model parameter, $\omega$ (Equations 1 & 2). Posterior distributions of this parameter overlapped 1 for all of our dipper function data sets (see top right panel in [@fig-bayesianmodel]), indicating strong interocular suppression regardless of post-retinal pathway. The flickering disc stimuli produced a slightly lower suppression estimate, with $\omega \sim 0.9$. This may indicate slightly weaker suppression between the eyes for temporal modulations, but it is much less extreme than our recent estimates using EEG and matching paradigms [@Segala2023]. One difference between these studies is the luminance of the background, which was set to black for the experiments of @Segala2023, but here was set at the mean luminance. Other studies using static luminance increments have also reported differences in the character of binocular combination that are attributable to background luminance [@Baker2012], so this may explain the differences between studies. We also note that the weaker interocular suppression for flickering disc stimuli appears to be largely due to one participant (see [@fig-individualdiscs]c), so individual differences might also play a role. Future work should manipulate the background luminance systematically to better understand how this modulates interocular suppression.

## Psychometric slopes

Previous work has demonstrated that the slope of the psychometric function in 2AFC tasks can distinguish different types of masking, although it is much less widely reported than threshold measures. In particular, pedestal masking linearizes the slope [@Foley1981; @Meese2006], and within-channel dichoptic masking produces very steep slopes [@Meese2006; @Baker2013]. We replicate both of these effects here, and show that they extend to isoluminant chromatic pathways (see [@fig-dipperfig]d-f & @fig-MCSfig). We additionally show that dichoptic masking between different pathways does not produce unusually steep slopes (see [@fig-MCSfig]). It therefore more closely resembles other types of masking between visual channels, such as cross-orientation masking [@Meese2009], surround masking [@Yu2002], and masking from broadband noise [@Baker2012b; @Lu2008], which also do not impact psychometric slopes.

## Physiological substrates

Recent evidence indicates that the physiological substrate of interocular suppression may be neurons in layer 4 of primary visual cortex [@Dougherty2019]. Most cells in this layer are monocularly exciteable, in that their responses increase only by stimulation of their preferred eye. However, simultaneous stimulation of the non-preferred eye can modulate the response, usually in an inhibitory fashion, exactly as proposed at stage 1 of the two-stage model (Equations 1 & 2). In terms of perception, one consequence of this early suppression is to achieve 'ocularity invariance', whereby the perceived contrast of a stimulus viewed by one eye is equivalent to that of the same stimulus viewed by both eyes [@Baker2007]. Similar processes of invariance have also been reported using fMRI [@Moradi2009] and steady-state EEG [@Baker2017].

In V1, chromatic stimuli are processed in 'blob' regions that are largely monocular as they fall within ocular dominance columns [@Livingstone1984]. Since our psychophysical results indicate that interocular suppression is equally strong within chromatic and achromatic pathways, it may be that blob regions include interocular suppression. Presumably binocular summation of signals occurs at a later stage of processing for chromatic stimuli, but this does not lead to different perceptual outcomes. This physiological arrangement might also be responsible for the pattern of between-pathway interocular suppression (see [@fig-MCSfig]g). If blobs process signals from both the L-M and S-(L+M) pathways, their close physical proximity might explain the stronger suppression between the two chromatic pathways than between the chromatic and (more distant) achromatic pathways.

# Conclusions

Here we provide estimates of interocular suppression within and between the three primary post-retinal visual pathways. These results show that binocular signal combination is similar within each pathway, but that interocular suppression is relatively weak between pathways. Our findings could be applied when building models to predict perception of binocular images and movies, for example those generated by virtual and augmented reality systems, or in 3D cinema and television.

# Acknowledgements

Supported by BBSRC grant BB/V007580/1 awarded to DHB and ARW.

# References

<div id='refs'> </div>

# Appendices

\beginsupplement

![Individual participant data from Experiment 1.](Figures/individualdippers.pdf){#fig-individualdippers}

![Individual participant data from Experiment 2.](Figures/individualMCS.pdf){#fig-individualMCS}

![Individual participant data from Experiment 3.](Figures/individualdiscs.pdf){#fig-individualdiscs}
